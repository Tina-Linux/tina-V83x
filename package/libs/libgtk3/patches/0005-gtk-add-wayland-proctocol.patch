From 780bd5b3f754361b3b7b677b6c234d119e662e51 Mon Sep 17 00:00:00 2001
From: xielinfei <xielinfei@allwinnertech.com>
Date: Mon, 5 Feb 2018 13:50:15 +0800
Subject: [PATCH] gtk+: add wayland protocol

Signed-off-by: xielinfei <xielinfei@allwinnertech.com>
---
 .../gtk-primary-selection-client-protocol.h        |  580 +++++
 gdk/wayland/gtk-primary-selection-protocol.c       |  105 +
 gdk/wayland/gtk-shell-client-protocol.h            |  293 +++
 gdk/wayland/gtk-shell-protocol.c                   |   54 +
 .../pointer-gestures-unstable-v1-client-protocol.h |  484 +++++
 .../pointer-gestures-unstable-v1-protocol.c        |   74 +
 gdk/wayland/tablet-unstable-v2-client-protocol.h   | 2239 ++++++++++++++++++++
 gdk/wayland/tablet-unstable-v2-protocol.c          |  223 ++
 .../xdg-foreign-unstable-v1-client-protocol.h      |  477 +++++
 gdk/wayland/xdg-foreign-unstable-v1-protocol.c     |   93 +
 .../xdg-shell-unstable-v6-client-protocol.h        | 1744 +++++++++++++++
 gdk/wayland/xdg-shell-unstable-v6-protocol.c       |  162 ++
 12 files changed, 6528 insertions(+)
 create mode 100755 gdk/wayland/gtk-primary-selection-client-protocol.h
 create mode 100755 gdk/wayland/gtk-primary-selection-protocol.c
 create mode 100755 gdk/wayland/gtk-shell-client-protocol.h
 create mode 100755 gdk/wayland/gtk-shell-protocol.c
 create mode 100755 gdk/wayland/pointer-gestures-unstable-v1-client-protocol.h
 create mode 100755 gdk/wayland/pointer-gestures-unstable-v1-protocol.c
 create mode 100755 gdk/wayland/tablet-unstable-v2-client-protocol.h
 create mode 100755 gdk/wayland/tablet-unstable-v2-protocol.c
 create mode 100755 gdk/wayland/xdg-foreign-unstable-v1-client-protocol.h
 create mode 100755 gdk/wayland/xdg-foreign-unstable-v1-protocol.c
 create mode 100755 gdk/wayland/xdg-shell-unstable-v6-client-protocol.h
 create mode 100755 gdk/wayland/xdg-shell-unstable-v6-protocol.c

diff --git a/gdk/wayland/gtk-primary-selection-client-protocol.h b/gdk/wayland/gtk-primary-selection-client-protocol.h
new file mode 100755
index 0000000..823ebf9
--- /dev/null
+++ b/gdk/wayland/gtk-primary-selection-client-protocol.h
@@ -0,0 +1,580 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef GTK_PRIMARY_SELECTION_CLIENT_PROTOCOL_H
+#define GTK_PRIMARY_SELECTION_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_gtk_primary_selection The gtk_primary_selection protocol
+ * Primary selection protocol
+ *
+ * @section page_desc_gtk_primary_selection Description
+ *
+ * This protocol provides the ability to have a primary selection device to
+ * match that of the X server. This primary selection is a shortcut to the
+ * common clipboard selection, where text just needs to be selected in order
+ * to allow copying it elsewhere. The de facto way to perform this action
+ * is the middle mouse button, although it is not limited to this one.
+ *
+ * Clients wishing to honor primary selection should create a primary
+ * selection source and set it as the selection through
+ * wp_primary_selection_device.set_selection whenever the text selection
+ * changes. In order to minimize calls in pointer-driven text selection,
+ * it should happen only once after the operation finished. Similarly,
+ * a NULL source should be set when text is unselected.
+ *
+ * wp_primary_selection_offer objects are first announced through the
+ * wp_primary_selection_device.data_offer event. Immediately after this event,
+ * the primary data offer will emit wp_primary_selection_offer.offer events
+ * to let know of the mime types being offered.
+ *
+ * When the primary selection changes, the client with the keyboard focus
+ * will receive wp_primary_selection_device.selection events. Only the client
+ * with the keyboard focus will receive such events with a non-NULL
+ * wp_primary_selection_offer. Across keyboard focus changes, previously
+ * focused clients will receive wp_primary_selection_device.events with a
+ * NULL wp_primary_selection_offer.
+ *
+ * In order to request the primary selection data, the client must pass
+ * a recent serial pertaining to the press event that is triggering the
+ * operation, if the compositor deems the serial valid and recent, the
+ * wp_primary_selection_source.send event will happen in the other end
+ * to let the transfer begin. The client owning the primary selection
+ * should write the requested data, and close the file descriptor
+ * immediately.
+ *
+ * If the primary selection owner client disappeared during the transfer,
+ * the client reading the data will receive a
+ * wp_primary_selection_device.selection event with a NULL
+ * wp_primary_selection_offer, the client should take this as a hint
+ * to finish the reads related to the no longer existing offer.
+ *
+ * The primary selection owner should be checking for errors during
+ * writes, merely cancelling the ongoing transfer if any happened.
+ *
+ * @section page_ifaces_gtk_primary_selection Interfaces
+ * - @subpage page_iface_gtk_primary_selection_device_manager - X primary selection emulation
+ * - @subpage page_iface_gtk_primary_selection_device - 
+ * - @subpage page_iface_gtk_primary_selection_offer - offer to transfer primary selection contents
+ * - @subpage page_iface_gtk_primary_selection_source - offer to replace the contents of the primary selection
+ * @section page_copyright_gtk_primary_selection Copyright
+ * <pre>
+ *
+ * Copyright © 2015, 2016 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct gtk_primary_selection_device;
+struct gtk_primary_selection_device_manager;
+struct gtk_primary_selection_offer;
+struct gtk_primary_selection_source;
+struct wl_seat;
+
+/**
+ * @page page_iface_gtk_primary_selection_device_manager gtk_primary_selection_device_manager
+ * @section page_iface_gtk_primary_selection_device_manager_desc Description
+ *
+ * The primary selection device manager is a singleton global object that
+ * provides access to the primary selection. It allows to create
+ * wp_primary_selection_source objects, as well as retrieving the per-seat
+ * wp_primary_selection_device objects.
+ * @section page_iface_gtk_primary_selection_device_manager_api API
+ * See @ref iface_gtk_primary_selection_device_manager.
+ */
+/**
+ * @defgroup iface_gtk_primary_selection_device_manager The gtk_primary_selection_device_manager interface
+ *
+ * The primary selection device manager is a singleton global object that
+ * provides access to the primary selection. It allows to create
+ * wp_primary_selection_source objects, as well as retrieving the per-seat
+ * wp_primary_selection_device objects.
+ */
+extern const struct wl_interface gtk_primary_selection_device_manager_interface;
+/**
+ * @page page_iface_gtk_primary_selection_device gtk_primary_selection_device
+ * @section page_iface_gtk_primary_selection_device_api API
+ * See @ref iface_gtk_primary_selection_device.
+ */
+/**
+ * @defgroup iface_gtk_primary_selection_device The gtk_primary_selection_device interface
+ */
+extern const struct wl_interface gtk_primary_selection_device_interface;
+/**
+ * @page page_iface_gtk_primary_selection_offer gtk_primary_selection_offer
+ * @section page_iface_gtk_primary_selection_offer_desc Description
+ *
+ * A wp_primary_selection_offer represents an offer to transfer the contents
+ * of the primary selection clipboard to the client. Similar to
+ * wl_data_offer, the offer also describes the mime types that the source
+ * will transferthat the
+ * data can be converted to and provides the mechanisms for transferring the
+ * data directly to the client.
+ * @section page_iface_gtk_primary_selection_offer_api API
+ * See @ref iface_gtk_primary_selection_offer.
+ */
+/**
+ * @defgroup iface_gtk_primary_selection_offer The gtk_primary_selection_offer interface
+ *
+ * A wp_primary_selection_offer represents an offer to transfer the contents
+ * of the primary selection clipboard to the client. Similar to
+ * wl_data_offer, the offer also describes the mime types that the source
+ * will transferthat the
+ * data can be converted to and provides the mechanisms for transferring the
+ * data directly to the client.
+ */
+extern const struct wl_interface gtk_primary_selection_offer_interface;
+/**
+ * @page page_iface_gtk_primary_selection_source gtk_primary_selection_source
+ * @section page_iface_gtk_primary_selection_source_desc Description
+ *
+ * The source side of a wp_primary_selection_offer, it provides a way to
+ * describe the offered data and respond to requests to transfer the
+ * requested contents of the primary selection clipboard.
+ * @section page_iface_gtk_primary_selection_source_api API
+ * See @ref iface_gtk_primary_selection_source.
+ */
+/**
+ * @defgroup iface_gtk_primary_selection_source The gtk_primary_selection_source interface
+ *
+ * The source side of a wp_primary_selection_offer, it provides a way to
+ * describe the offered data and respond to requests to transfer the
+ * requested contents of the primary selection clipboard.
+ */
+extern const struct wl_interface gtk_primary_selection_source_interface;
+
+#define GTK_PRIMARY_SELECTION_DEVICE_MANAGER_CREATE_SOURCE 0
+#define GTK_PRIMARY_SELECTION_DEVICE_MANAGER_GET_DEVICE 1
+#define GTK_PRIMARY_SELECTION_DEVICE_MANAGER_DESTROY 2
+
+
+/**
+ * @ingroup iface_gtk_primary_selection_device_manager
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_MANAGER_CREATE_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_device_manager
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_MANAGER_GET_DEVICE_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_device_manager
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_MANAGER_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_gtk_primary_selection_device_manager */
+static inline void
+gtk_primary_selection_device_manager_set_user_data(struct gtk_primary_selection_device_manager *gtk_primary_selection_device_manager, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) gtk_primary_selection_device_manager, user_data);
+}
+
+/** @ingroup iface_gtk_primary_selection_device_manager */
+static inline void *
+gtk_primary_selection_device_manager_get_user_data(struct gtk_primary_selection_device_manager *gtk_primary_selection_device_manager)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) gtk_primary_selection_device_manager);
+}
+
+static inline uint32_t
+gtk_primary_selection_device_manager_get_version(struct gtk_primary_selection_device_manager *gtk_primary_selection_device_manager)
+{
+	return wl_proxy_get_version((struct wl_proxy *) gtk_primary_selection_device_manager);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_device_manager
+ *
+ * Create a new primary selection source.
+ */
+static inline struct gtk_primary_selection_source *
+gtk_primary_selection_device_manager_create_source(struct gtk_primary_selection_device_manager *gtk_primary_selection_device_manager)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) gtk_primary_selection_device_manager,
+			 GTK_PRIMARY_SELECTION_DEVICE_MANAGER_CREATE_SOURCE, &gtk_primary_selection_source_interface, NULL);
+
+	return (struct gtk_primary_selection_source *) id;
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_device_manager
+ *
+ * Create a new data device for a given seat.
+ */
+static inline struct gtk_primary_selection_device *
+gtk_primary_selection_device_manager_get_device(struct gtk_primary_selection_device_manager *gtk_primary_selection_device_manager, struct wl_seat *seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) gtk_primary_selection_device_manager,
+			 GTK_PRIMARY_SELECTION_DEVICE_MANAGER_GET_DEVICE, &gtk_primary_selection_device_interface, NULL, seat);
+
+	return (struct gtk_primary_selection_device *) id;
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_device_manager
+ *
+ * Destroy the primary selection device manager.
+ */
+static inline void
+gtk_primary_selection_device_manager_destroy(struct gtk_primary_selection_device_manager *gtk_primary_selection_device_manager)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_device_manager,
+			 GTK_PRIMARY_SELECTION_DEVICE_MANAGER_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) gtk_primary_selection_device_manager);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ * @struct gtk_primary_selection_device_listener
+ */
+struct gtk_primary_selection_device_listener {
+	/**
+	 * introduce a new wp_primary_selection_offer
+	 *
+	 * Introduces a new wp_primary_selection_offer object that may be
+	 * used to receive the current primary selection. Immediately
+	 * following this event, the new wp_primary_selection_offer object
+	 * will send wp_primary_selection_offer.offer events to describe
+	 * the offered mime types.
+	 */
+	void (*data_offer)(void *data,
+			   struct gtk_primary_selection_device *gtk_primary_selection_device,
+			   struct gtk_primary_selection_offer *offer);
+	/**
+	 * advertise a new primary selection
+	 *
+	 * The wp_primary_selection_device.selection event is sent to
+	 * notify the client of a new primary selection. This event is sent
+	 * after the wp_primary_selection.data_offer event introducing this
+	 * object, and after the offer has announced its mimetypes through
+	 * wp_primary_selection_offer.offer.
+	 *
+	 * The data_offer is valid until a new offer or NULL is received or
+	 * until the client loses keyboard focus. The client must destroy
+	 * the previous selection data_offer, if any, upon receiving this
+	 * event.
+	 */
+	void (*selection)(void *data,
+			  struct gtk_primary_selection_device *gtk_primary_selection_device,
+			  struct gtk_primary_selection_offer *id);
+};
+
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ */
+static inline int
+gtk_primary_selection_device_add_listener(struct gtk_primary_selection_device *gtk_primary_selection_device,
+					  const struct gtk_primary_selection_device_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) gtk_primary_selection_device,
+				     (void (**)(void)) listener, data);
+}
+
+#define GTK_PRIMARY_SELECTION_DEVICE_SET_SELECTION 0
+#define GTK_PRIMARY_SELECTION_DEVICE_DESTROY 1
+
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_DATA_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_SELECTION_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_SET_SELECTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ */
+#define GTK_PRIMARY_SELECTION_DEVICE_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_gtk_primary_selection_device */
+static inline void
+gtk_primary_selection_device_set_user_data(struct gtk_primary_selection_device *gtk_primary_selection_device, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) gtk_primary_selection_device, user_data);
+}
+
+/** @ingroup iface_gtk_primary_selection_device */
+static inline void *
+gtk_primary_selection_device_get_user_data(struct gtk_primary_selection_device *gtk_primary_selection_device)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) gtk_primary_selection_device);
+}
+
+static inline uint32_t
+gtk_primary_selection_device_get_version(struct gtk_primary_selection_device *gtk_primary_selection_device)
+{
+	return wl_proxy_get_version((struct wl_proxy *) gtk_primary_selection_device);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ *
+ * Replaces the current selection. The previous owner of the primary selection
+ * will receive a wp_primary_selection_source.cancelled event.
+ *
+ * To unset the selection, set the source to NULL.
+ */
+static inline void
+gtk_primary_selection_device_set_selection(struct gtk_primary_selection_device *gtk_primary_selection_device, struct gtk_primary_selection_source *source, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_device,
+			 GTK_PRIMARY_SELECTION_DEVICE_SET_SELECTION, source, serial);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_device
+ *
+ * Destroy the primary selection device.
+ */
+static inline void
+gtk_primary_selection_device_destroy(struct gtk_primary_selection_device *gtk_primary_selection_device)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_device,
+			 GTK_PRIMARY_SELECTION_DEVICE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) gtk_primary_selection_device);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ * @struct gtk_primary_selection_offer_listener
+ */
+struct gtk_primary_selection_offer_listener {
+	/**
+	 * advertise offered mime type
+	 *
+	 * Sent immediately after creating announcing the
+	 * wp_primary_selection_offer through
+	 * wp_primary_selection_device.data_offer. One event is sent per
+	 * offered mime type.
+	 */
+	void (*offer)(void *data,
+		      struct gtk_primary_selection_offer *gtk_primary_selection_offer,
+		      const char *mime_type);
+};
+
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ */
+static inline int
+gtk_primary_selection_offer_add_listener(struct gtk_primary_selection_offer *gtk_primary_selection_offer,
+					 const struct gtk_primary_selection_offer_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) gtk_primary_selection_offer,
+				     (void (**)(void)) listener, data);
+}
+
+#define GTK_PRIMARY_SELECTION_OFFER_RECEIVE 0
+#define GTK_PRIMARY_SELECTION_OFFER_DESTROY 1
+
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ */
+#define GTK_PRIMARY_SELECTION_OFFER_OFFER_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ */
+#define GTK_PRIMARY_SELECTION_OFFER_RECEIVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ */
+#define GTK_PRIMARY_SELECTION_OFFER_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_gtk_primary_selection_offer */
+static inline void
+gtk_primary_selection_offer_set_user_data(struct gtk_primary_selection_offer *gtk_primary_selection_offer, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) gtk_primary_selection_offer, user_data);
+}
+
+/** @ingroup iface_gtk_primary_selection_offer */
+static inline void *
+gtk_primary_selection_offer_get_user_data(struct gtk_primary_selection_offer *gtk_primary_selection_offer)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) gtk_primary_selection_offer);
+}
+
+static inline uint32_t
+gtk_primary_selection_offer_get_version(struct gtk_primary_selection_offer *gtk_primary_selection_offer)
+{
+	return wl_proxy_get_version((struct wl_proxy *) gtk_primary_selection_offer);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ *
+ * To transfer the contents of the primary selection clipboard, the client
+ * issues this request and indicates the mime type that it wants to
+ * receive. The transfer happens through the passed file descriptor
+ * (typically created with the pipe system call). The source client writes
+ * the data in the mime type representation requested and then closes the
+ * file descriptor.
+ *
+ * The receiving client reads from the read end of the pipe until EOF and
+ * closes its end, at which point the transfer is complete.
+ */
+static inline void
+gtk_primary_selection_offer_receive(struct gtk_primary_selection_offer *gtk_primary_selection_offer, const char *mime_type, int32_t fd)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_offer,
+			 GTK_PRIMARY_SELECTION_OFFER_RECEIVE, mime_type, fd);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_offer
+ *
+ * Destroy the primary selection offer.
+ */
+static inline void
+gtk_primary_selection_offer_destroy(struct gtk_primary_selection_offer *gtk_primary_selection_offer)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_offer,
+			 GTK_PRIMARY_SELECTION_OFFER_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) gtk_primary_selection_offer);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ * @struct gtk_primary_selection_source_listener
+ */
+struct gtk_primary_selection_source_listener {
+	/**
+	 * send the primary selection contents
+	 *
+	 * Request for the current primary selection contents from the
+	 * client. Send the specified mime type over the passed file
+	 * descriptor, then close it.
+	 */
+	void (*send)(void *data,
+		     struct gtk_primary_selection_source *gtk_primary_selection_source,
+		     const char *mime_type,
+		     int32_t fd);
+	/**
+	 * request for primary selection contents was canceled
+	 *
+	 * This primary selection source is no longer valid. The client
+	 * should clean up and destroy this primary selection source.
+	 */
+	void (*cancelled)(void *data,
+			  struct gtk_primary_selection_source *gtk_primary_selection_source);
+};
+
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ */
+static inline int
+gtk_primary_selection_source_add_listener(struct gtk_primary_selection_source *gtk_primary_selection_source,
+					  const struct gtk_primary_selection_source_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) gtk_primary_selection_source,
+				     (void (**)(void)) listener, data);
+}
+
+#define GTK_PRIMARY_SELECTION_SOURCE_OFFER 0
+#define GTK_PRIMARY_SELECTION_SOURCE_DESTROY 1
+
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ */
+#define GTK_PRIMARY_SELECTION_SOURCE_SEND_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ */
+#define GTK_PRIMARY_SELECTION_SOURCE_CANCELLED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ */
+#define GTK_PRIMARY_SELECTION_SOURCE_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ */
+#define GTK_PRIMARY_SELECTION_SOURCE_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_gtk_primary_selection_source */
+static inline void
+gtk_primary_selection_source_set_user_data(struct gtk_primary_selection_source *gtk_primary_selection_source, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) gtk_primary_selection_source, user_data);
+}
+
+/** @ingroup iface_gtk_primary_selection_source */
+static inline void *
+gtk_primary_selection_source_get_user_data(struct gtk_primary_selection_source *gtk_primary_selection_source)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) gtk_primary_selection_source);
+}
+
+static inline uint32_t
+gtk_primary_selection_source_get_version(struct gtk_primary_selection_source *gtk_primary_selection_source)
+{
+	return wl_proxy_get_version((struct wl_proxy *) gtk_primary_selection_source);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ *
+ * This request adds a mime type to the set of mime types advertised to
+ * targets. Can be called several times to offer multiple types.
+ */
+static inline void
+gtk_primary_selection_source_offer(struct gtk_primary_selection_source *gtk_primary_selection_source, const char *mime_type)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_source,
+			 GTK_PRIMARY_SELECTION_SOURCE_OFFER, mime_type);
+}
+
+/**
+ * @ingroup iface_gtk_primary_selection_source
+ *
+ * Destroy the primary selection source.
+ */
+static inline void
+gtk_primary_selection_source_destroy(struct gtk_primary_selection_source *gtk_primary_selection_source)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_primary_selection_source,
+			 GTK_PRIMARY_SELECTION_SOURCE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) gtk_primary_selection_source);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gdk/wayland/gtk-primary-selection-protocol.c b/gdk/wayland/gtk-primary-selection-protocol.c
new file mode 100755
index 0000000..a55dce9
--- /dev/null
+++ b/gdk/wayland/gtk-primary-selection-protocol.c
@@ -0,0 +1,105 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+/*
+ * Copyright © 2015, 2016 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface gtk_primary_selection_device_interface;
+extern const struct wl_interface gtk_primary_selection_offer_interface;
+extern const struct wl_interface gtk_primary_selection_source_interface;
+extern const struct wl_interface wl_seat_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	&gtk_primary_selection_source_interface,
+	&gtk_primary_selection_device_interface,
+	&wl_seat_interface,
+	&gtk_primary_selection_source_interface,
+	NULL,
+	&gtk_primary_selection_offer_interface,
+	&gtk_primary_selection_offer_interface,
+};
+
+static const struct wl_message gtk_primary_selection_device_manager_requests[] = {
+	{ "create_source", "n", types + 2 },
+	{ "get_device", "no", types + 3 },
+	{ "destroy", "", types + 0 },
+};
+
+const struct wl_interface gtk_primary_selection_device_manager_interface = {
+	"gtk_primary_selection_device_manager", 1,
+	3, gtk_primary_selection_device_manager_requests,
+	0, NULL,
+};
+
+static const struct wl_message gtk_primary_selection_device_requests[] = {
+	{ "set_selection", "?ou", types + 5 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message gtk_primary_selection_device_events[] = {
+	{ "data_offer", "n", types + 7 },
+	{ "selection", "?o", types + 8 },
+};
+
+const struct wl_interface gtk_primary_selection_device_interface = {
+	"gtk_primary_selection_device", 1,
+	2, gtk_primary_selection_device_requests,
+	2, gtk_primary_selection_device_events,
+};
+
+static const struct wl_message gtk_primary_selection_offer_requests[] = {
+	{ "receive", "sh", types + 0 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message gtk_primary_selection_offer_events[] = {
+	{ "offer", "s", types + 0 },
+};
+
+const struct wl_interface gtk_primary_selection_offer_interface = {
+	"gtk_primary_selection_offer", 1,
+	2, gtk_primary_selection_offer_requests,
+	1, gtk_primary_selection_offer_events,
+};
+
+static const struct wl_message gtk_primary_selection_source_requests[] = {
+	{ "offer", "s", types + 0 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message gtk_primary_selection_source_events[] = {
+	{ "send", "sh", types + 0 },
+	{ "cancelled", "", types + 0 },
+};
+
+const struct wl_interface gtk_primary_selection_source_interface = {
+	"gtk_primary_selection_source", 1,
+	2, gtk_primary_selection_source_requests,
+	2, gtk_primary_selection_source_events,
+};
+
diff --git a/gdk/wayland/gtk-shell-client-protocol.h b/gdk/wayland/gtk-shell-client-protocol.h
new file mode 100755
index 0000000..6baa58d
--- /dev/null
+++ b/gdk/wayland/gtk-shell-client-protocol.h
@@ -0,0 +1,293 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef GTK_CLIENT_PROTOCOL_H
+#define GTK_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_gtk The gtk protocol
+ * @section page_ifaces_gtk Interfaces
+ * - @subpage page_iface_gtk_shell1 - gtk specific extensions
+ * - @subpage page_iface_gtk_surface1 - 
+ */
+struct gtk_shell1;
+struct gtk_surface1;
+struct wl_surface;
+
+/**
+ * @page page_iface_gtk_shell1 gtk_shell1
+ * @section page_iface_gtk_shell1_desc Description
+ *
+ * gtk_shell is a protocol extension providing additional features for
+ * clients implementing it.
+ * @section page_iface_gtk_shell1_api API
+ * See @ref iface_gtk_shell1.
+ */
+/**
+ * @defgroup iface_gtk_shell1 The gtk_shell1 interface
+ *
+ * gtk_shell is a protocol extension providing additional features for
+ * clients implementing it.
+ */
+extern const struct wl_interface gtk_shell1_interface;
+/**
+ * @page page_iface_gtk_surface1 gtk_surface1
+ * @section page_iface_gtk_surface1_api API
+ * See @ref iface_gtk_surface1.
+ */
+/**
+ * @defgroup iface_gtk_surface1 The gtk_surface1 interface
+ */
+extern const struct wl_interface gtk_surface1_interface;
+
+#ifndef GTK_SHELL1_CAPABILITY_ENUM
+#define GTK_SHELL1_CAPABILITY_ENUM
+enum gtk_shell1_capability {
+	GTK_SHELL1_CAPABILITY_GLOBAL_APP_MENU = 1,
+	GTK_SHELL1_CAPABILITY_GLOBAL_MENU_BAR = 2,
+	GTK_SHELL1_CAPABILITY_DESKTOP_ICONS = 3,
+};
+#endif /* GTK_SHELL1_CAPABILITY_ENUM */
+
+/**
+ * @ingroup iface_gtk_shell1
+ * @struct gtk_shell1_listener
+ */
+struct gtk_shell1_listener {
+	/**
+	 */
+	void (*capabilities)(void *data,
+			     struct gtk_shell1 *gtk_shell1,
+			     uint32_t capabilities);
+};
+
+/**
+ * @ingroup iface_gtk_shell1
+ */
+static inline int
+gtk_shell1_add_listener(struct gtk_shell1 *gtk_shell1,
+			const struct gtk_shell1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) gtk_shell1,
+				     (void (**)(void)) listener, data);
+}
+
+#define GTK_SHELL1_GET_GTK_SURFACE 0
+#define GTK_SHELL1_SET_STARTUP_ID 1
+#define GTK_SHELL1_SYSTEM_BELL 2
+
+/**
+ * @ingroup iface_gtk_shell1
+ */
+#define GTK_SHELL1_CAPABILITIES_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_gtk_shell1
+ */
+#define GTK_SHELL1_GET_GTK_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_shell1
+ */
+#define GTK_SHELL1_SET_STARTUP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_shell1
+ */
+#define GTK_SHELL1_SYSTEM_BELL_SINCE_VERSION 1
+
+/** @ingroup iface_gtk_shell1 */
+static inline void
+gtk_shell1_set_user_data(struct gtk_shell1 *gtk_shell1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) gtk_shell1, user_data);
+}
+
+/** @ingroup iface_gtk_shell1 */
+static inline void *
+gtk_shell1_get_user_data(struct gtk_shell1 *gtk_shell1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) gtk_shell1);
+}
+
+static inline uint32_t
+gtk_shell1_get_version(struct gtk_shell1 *gtk_shell1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) gtk_shell1);
+}
+
+/** @ingroup iface_gtk_shell1 */
+static inline void
+gtk_shell1_destroy(struct gtk_shell1 *gtk_shell1)
+{
+	wl_proxy_destroy((struct wl_proxy *) gtk_shell1);
+}
+
+/**
+ * @ingroup iface_gtk_shell1
+ */
+static inline struct gtk_surface1 *
+gtk_shell1_get_gtk_surface(struct gtk_shell1 *gtk_shell1, struct wl_surface *surface)
+{
+	struct wl_proxy *gtk_surface;
+
+	gtk_surface = wl_proxy_marshal_constructor((struct wl_proxy *) gtk_shell1,
+			 GTK_SHELL1_GET_GTK_SURFACE, &gtk_surface1_interface, NULL, surface);
+
+	return (struct gtk_surface1 *) gtk_surface;
+}
+
+/**
+ * @ingroup iface_gtk_shell1
+ */
+static inline void
+gtk_shell1_set_startup_id(struct gtk_shell1 *gtk_shell1, const char *startup_id)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_shell1,
+			 GTK_SHELL1_SET_STARTUP_ID, startup_id);
+}
+
+/**
+ * @ingroup iface_gtk_shell1
+ */
+static inline void
+gtk_shell1_system_bell(struct gtk_shell1 *gtk_shell1, struct gtk_surface1 *surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_shell1,
+			 GTK_SHELL1_SYSTEM_BELL, surface);
+}
+
+#ifndef GTK_SURFACE1_STATE_ENUM
+#define GTK_SURFACE1_STATE_ENUM
+enum gtk_surface1_state {
+	GTK_SURFACE1_STATE_TILED = 1,
+};
+#endif /* GTK_SURFACE1_STATE_ENUM */
+
+/**
+ * @ingroup iface_gtk_surface1
+ * @struct gtk_surface1_listener
+ */
+struct gtk_surface1_listener {
+	/**
+	 */
+	void (*configure)(void *data,
+			  struct gtk_surface1 *gtk_surface1,
+			  struct wl_array *states);
+};
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+static inline int
+gtk_surface1_add_listener(struct gtk_surface1 *gtk_surface1,
+			  const struct gtk_surface1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) gtk_surface1,
+				     (void (**)(void)) listener, data);
+}
+
+#define GTK_SURFACE1_SET_DBUS_PROPERTIES 0
+#define GTK_SURFACE1_SET_MODAL 1
+#define GTK_SURFACE1_UNSET_MODAL 2
+#define GTK_SURFACE1_PRESENT 3
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+#define GTK_SURFACE1_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+#define GTK_SURFACE1_SET_DBUS_PROPERTIES_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_surface1
+ */
+#define GTK_SURFACE1_SET_MODAL_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_surface1
+ */
+#define GTK_SURFACE1_UNSET_MODAL_SINCE_VERSION 1
+/**
+ * @ingroup iface_gtk_surface1
+ */
+#define GTK_SURFACE1_PRESENT_SINCE_VERSION 1
+
+/** @ingroup iface_gtk_surface1 */
+static inline void
+gtk_surface1_set_user_data(struct gtk_surface1 *gtk_surface1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) gtk_surface1, user_data);
+}
+
+/** @ingroup iface_gtk_surface1 */
+static inline void *
+gtk_surface1_get_user_data(struct gtk_surface1 *gtk_surface1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) gtk_surface1);
+}
+
+static inline uint32_t
+gtk_surface1_get_version(struct gtk_surface1 *gtk_surface1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) gtk_surface1);
+}
+
+/** @ingroup iface_gtk_surface1 */
+static inline void
+gtk_surface1_destroy(struct gtk_surface1 *gtk_surface1)
+{
+	wl_proxy_destroy((struct wl_proxy *) gtk_surface1);
+}
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+static inline void
+gtk_surface1_set_dbus_properties(struct gtk_surface1 *gtk_surface1, const char *application_id, const char *app_menu_path, const char *menubar_path, const char *window_object_path, const char *application_object_path, const char *unique_bus_name)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_surface1,
+			 GTK_SURFACE1_SET_DBUS_PROPERTIES, application_id, app_menu_path, menubar_path, window_object_path, application_object_path, unique_bus_name);
+}
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+static inline void
+gtk_surface1_set_modal(struct gtk_surface1 *gtk_surface1)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_surface1,
+			 GTK_SURFACE1_SET_MODAL);
+}
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+static inline void
+gtk_surface1_unset_modal(struct gtk_surface1 *gtk_surface1)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_surface1,
+			 GTK_SURFACE1_UNSET_MODAL);
+}
+
+/**
+ * @ingroup iface_gtk_surface1
+ */
+static inline void
+gtk_surface1_present(struct gtk_surface1 *gtk_surface1, uint32_t time)
+{
+	wl_proxy_marshal((struct wl_proxy *) gtk_surface1,
+			 GTK_SURFACE1_PRESENT, time);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gdk/wayland/gtk-shell-protocol.c b/gdk/wayland/gtk-shell-protocol.c
new file mode 100755
index 0000000..bc37768
--- /dev/null
+++ b/gdk/wayland/gtk-shell-protocol.c
@@ -0,0 +1,54 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface gtk_surface1_interface;
+extern const struct wl_interface wl_surface_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&gtk_surface1_interface,
+	&wl_surface_interface,
+	&gtk_surface1_interface,
+};
+
+static const struct wl_message gtk_shell1_requests[] = {
+	{ "get_gtk_surface", "no", types + 6 },
+	{ "set_startup_id", "?s", types + 0 },
+	{ "system_bell", "?o", types + 8 },
+};
+
+static const struct wl_message gtk_shell1_events[] = {
+	{ "capabilities", "u", types + 0 },
+};
+
+const struct wl_interface gtk_shell1_interface = {
+	"gtk_shell1", 1,
+	3, gtk_shell1_requests,
+	1, gtk_shell1_events,
+};
+
+static const struct wl_message gtk_surface1_requests[] = {
+	{ "set_dbus_properties", "?s?s?s?s?s?s", types + 0 },
+	{ "set_modal", "", types + 0 },
+	{ "unset_modal", "", types + 0 },
+	{ "present", "u", types + 0 },
+};
+
+static const struct wl_message gtk_surface1_events[] = {
+	{ "configure", "a", types + 0 },
+};
+
+const struct wl_interface gtk_surface1_interface = {
+	"gtk_surface1", 1,
+	4, gtk_surface1_requests,
+	1, gtk_surface1_events,
+};
+
diff --git a/gdk/wayland/pointer-gestures-unstable-v1-client-protocol.h b/gdk/wayland/pointer-gestures-unstable-v1-client-protocol.h
new file mode 100755
index 0000000..415dd83
--- /dev/null
+++ b/gdk/wayland/pointer-gestures-unstable-v1-client-protocol.h
@@ -0,0 +1,484 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef POINTER_GESTURES_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define POINTER_GESTURES_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_pointer_gestures_unstable_v1 The pointer_gestures_unstable_v1 protocol
+ * @section page_ifaces_pointer_gestures_unstable_v1 Interfaces
+ * - @subpage page_iface_zwp_pointer_gestures_v1 - touchpad gestures
+ * - @subpage page_iface_zwp_pointer_gesture_swipe_v1 - a swipe gesture object
+ * - @subpage page_iface_zwp_pointer_gesture_pinch_v1 - a pinch gesture object
+ */
+struct wl_pointer;
+struct wl_surface;
+struct zwp_pointer_gesture_pinch_v1;
+struct zwp_pointer_gesture_swipe_v1;
+struct zwp_pointer_gestures_v1;
+
+/**
+ * @page page_iface_zwp_pointer_gestures_v1 zwp_pointer_gestures_v1
+ * @section page_iface_zwp_pointer_gestures_v1_desc Description
+ *
+ * A global interface to provide semantic touchpad gestures for a given
+ * pointer.
+ *
+ * Two gestures are currently supported: swipe and zoom/rotate.
+ * All gestures follow a three-stage cycle: begin, update, end and
+ * are identified by a unique id.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ * @section page_iface_zwp_pointer_gestures_v1_api API
+ * See @ref iface_zwp_pointer_gestures_v1.
+ */
+/**
+ * @defgroup iface_zwp_pointer_gestures_v1 The zwp_pointer_gestures_v1 interface
+ *
+ * A global interface to provide semantic touchpad gestures for a given
+ * pointer.
+ *
+ * Two gestures are currently supported: swipe and zoom/rotate.
+ * All gestures follow a three-stage cycle: begin, update, end and
+ * are identified by a unique id.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ */
+extern const struct wl_interface zwp_pointer_gestures_v1_interface;
+/**
+ * @page page_iface_zwp_pointer_gesture_swipe_v1 zwp_pointer_gesture_swipe_v1
+ * @section page_iface_zwp_pointer_gesture_swipe_v1_desc Description
+ *
+ * A swipe gesture object notifies a client about a multi-finger swipe
+ * gesture detected on an indirect input device such as a touchpad.
+ * The gesture is usually initiated by multiple fingers moving in the
+ * same direction but once initiated the direction may change.
+ * The precise conditions of when such a gesture is detected are
+ * implementation-dependent.
+ *
+ * A gesture consists of three stages: begin, update (optional) and end.
+ * There cannot be multiple simultaneous pinch or swipe gestures on a
+ * same pointer/seat, how compositors prevent these situations is
+ * implementation-dependent.
+ *
+ * A gesture may be cancelled by the compositor or the hardware.
+ * Clients should not consider performing permanent or irreversible
+ * actions until the end of a gesture has been received.
+ * @section page_iface_zwp_pointer_gesture_swipe_v1_api API
+ * See @ref iface_zwp_pointer_gesture_swipe_v1.
+ */
+/**
+ * @defgroup iface_zwp_pointer_gesture_swipe_v1 The zwp_pointer_gesture_swipe_v1 interface
+ *
+ * A swipe gesture object notifies a client about a multi-finger swipe
+ * gesture detected on an indirect input device such as a touchpad.
+ * The gesture is usually initiated by multiple fingers moving in the
+ * same direction but once initiated the direction may change.
+ * The precise conditions of when such a gesture is detected are
+ * implementation-dependent.
+ *
+ * A gesture consists of three stages: begin, update (optional) and end.
+ * There cannot be multiple simultaneous pinch or swipe gestures on a
+ * same pointer/seat, how compositors prevent these situations is
+ * implementation-dependent.
+ *
+ * A gesture may be cancelled by the compositor or the hardware.
+ * Clients should not consider performing permanent or irreversible
+ * actions until the end of a gesture has been received.
+ */
+extern const struct wl_interface zwp_pointer_gesture_swipe_v1_interface;
+/**
+ * @page page_iface_zwp_pointer_gesture_pinch_v1 zwp_pointer_gesture_pinch_v1
+ * @section page_iface_zwp_pointer_gesture_pinch_v1_desc Description
+ *
+ * A pinch gesture object notifies a client about a multi-finger pinch
+ * gesture detected on an indirect input device such as a touchpad.
+ * The gesture is usually initiated by multiple fingers moving towards
+ * each other or away from each other, or by two or more fingers rotating
+ * around a logical center of gravity. The precise conditions of when
+ * such a gesture is detected are implementation-dependent.
+ *
+ * A gesture consists of three stages: begin, update (optional) and end.
+ * There cannot be multiple simultaneous pinch or swipe gestures on a
+ * same pointer/seat, how compositors prevent these situations is
+ * implementation-dependent.
+ *
+ * A gesture may be cancelled by the compositor or the hardware.
+ * Clients should not consider performing permanent or irreversible
+ * actions until the end of a gesture has been received.
+ * @section page_iface_zwp_pointer_gesture_pinch_v1_api API
+ * See @ref iface_zwp_pointer_gesture_pinch_v1.
+ */
+/**
+ * @defgroup iface_zwp_pointer_gesture_pinch_v1 The zwp_pointer_gesture_pinch_v1 interface
+ *
+ * A pinch gesture object notifies a client about a multi-finger pinch
+ * gesture detected on an indirect input device such as a touchpad.
+ * The gesture is usually initiated by multiple fingers moving towards
+ * each other or away from each other, or by two or more fingers rotating
+ * around a logical center of gravity. The precise conditions of when
+ * such a gesture is detected are implementation-dependent.
+ *
+ * A gesture consists of three stages: begin, update (optional) and end.
+ * There cannot be multiple simultaneous pinch or swipe gestures on a
+ * same pointer/seat, how compositors prevent these situations is
+ * implementation-dependent.
+ *
+ * A gesture may be cancelled by the compositor or the hardware.
+ * Clients should not consider performing permanent or irreversible
+ * actions until the end of a gesture has been received.
+ */
+extern const struct wl_interface zwp_pointer_gesture_pinch_v1_interface;
+
+#define ZWP_POINTER_GESTURES_V1_GET_SWIPE_GESTURE 0
+#define ZWP_POINTER_GESTURES_V1_GET_PINCH_GESTURE 1
+
+
+/**
+ * @ingroup iface_zwp_pointer_gestures_v1
+ */
+#define ZWP_POINTER_GESTURES_V1_GET_SWIPE_GESTURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_gestures_v1
+ */
+#define ZWP_POINTER_GESTURES_V1_GET_PINCH_GESTURE_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_pointer_gestures_v1 */
+static inline void
+zwp_pointer_gestures_v1_set_user_data(struct zwp_pointer_gestures_v1 *zwp_pointer_gestures_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_pointer_gestures_v1, user_data);
+}
+
+/** @ingroup iface_zwp_pointer_gestures_v1 */
+static inline void *
+zwp_pointer_gestures_v1_get_user_data(struct zwp_pointer_gestures_v1 *zwp_pointer_gestures_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_pointer_gestures_v1);
+}
+
+static inline uint32_t
+zwp_pointer_gestures_v1_get_version(struct zwp_pointer_gestures_v1 *zwp_pointer_gestures_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_pointer_gestures_v1);
+}
+
+/** @ingroup iface_zwp_pointer_gestures_v1 */
+static inline void
+zwp_pointer_gestures_v1_destroy(struct zwp_pointer_gestures_v1 *zwp_pointer_gestures_v1)
+{
+	wl_proxy_destroy((struct wl_proxy *) zwp_pointer_gestures_v1);
+}
+
+/**
+ * @ingroup iface_zwp_pointer_gestures_v1
+ *
+ * Create a swipe gesture object. See the
+ * wl_pointer_gesture_swipe interface for details.
+ */
+static inline struct zwp_pointer_gesture_swipe_v1 *
+zwp_pointer_gestures_v1_get_swipe_gesture(struct zwp_pointer_gestures_v1 *zwp_pointer_gestures_v1, struct wl_pointer *pointer)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_pointer_gestures_v1,
+			 ZWP_POINTER_GESTURES_V1_GET_SWIPE_GESTURE, &zwp_pointer_gesture_swipe_v1_interface, NULL, pointer);
+
+	return (struct zwp_pointer_gesture_swipe_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zwp_pointer_gestures_v1
+ *
+ * Create a pinch gesture object. See the
+ * wl_pointer_gesture_pinch interface for details.
+ */
+static inline struct zwp_pointer_gesture_pinch_v1 *
+zwp_pointer_gestures_v1_get_pinch_gesture(struct zwp_pointer_gestures_v1 *zwp_pointer_gestures_v1, struct wl_pointer *pointer)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_pointer_gestures_v1,
+			 ZWP_POINTER_GESTURES_V1_GET_PINCH_GESTURE, &zwp_pointer_gesture_pinch_v1_interface, NULL, pointer);
+
+	return (struct zwp_pointer_gesture_pinch_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ * @struct zwp_pointer_gesture_swipe_v1_listener
+ */
+struct zwp_pointer_gesture_swipe_v1_listener {
+	/**
+	 * multi-finger swipe begin
+	 *
+	 * This event is sent when a multi-finger swipe gesture is
+	 * detected on the device.
+	 * @param time timestamp with millisecond granularity
+	 * @param fingers number of fingers
+	 */
+	void (*begin)(void *data,
+		      struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1,
+		      uint32_t serial,
+		      uint32_t time,
+		      struct wl_surface *surface,
+		      uint32_t fingers);
+	/**
+	 * multi-finger swipe motion
+	 *
+	 * This event is sent when a multi-finger swipe gesture changes
+	 * the position of the logical center.
+	 *
+	 * The dx and dy coordinates are relative coordinates of the
+	 * logical center of the gesture compared to the previous event.
+	 * @param time timestamp with millisecond granularity
+	 * @param dx delta x coordinate in surface coordinate space
+	 * @param dy delta y coordinate in surface coordinate space
+	 */
+	void (*update)(void *data,
+		       struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1,
+		       uint32_t time,
+		       wl_fixed_t dx,
+		       wl_fixed_t dy);
+	/**
+	 * multi-finger swipe end
+	 *
+	 * This event is sent when a multi-finger swipe gesture ceases to
+	 * be valid. This may happen when one or more fingers are lifted or
+	 * the gesture is cancelled.
+	 *
+	 * When a gesture is cancelled, the client should undo state
+	 * changes caused by this gesture. What causes a gesture to be
+	 * cancelled is implementation-dependent.
+	 * @param time timestamp with millisecond granularity
+	 * @param cancelled 1 if the gesture was cancelled, 0 otherwise
+	 */
+	void (*end)(void *data,
+		    struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1,
+		    uint32_t serial,
+		    uint32_t time,
+		    int32_t cancelled);
+};
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ */
+static inline int
+zwp_pointer_gesture_swipe_v1_add_listener(struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1,
+					  const struct zwp_pointer_gesture_swipe_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_pointer_gesture_swipe_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_POINTER_GESTURE_SWIPE_V1_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ */
+#define ZWP_POINTER_GESTURE_SWIPE_V1_BEGIN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ */
+#define ZWP_POINTER_GESTURE_SWIPE_V1_UPDATE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ */
+#define ZWP_POINTER_GESTURE_SWIPE_V1_END_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ */
+#define ZWP_POINTER_GESTURE_SWIPE_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_pointer_gesture_swipe_v1 */
+static inline void
+zwp_pointer_gesture_swipe_v1_set_user_data(struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_pointer_gesture_swipe_v1, user_data);
+}
+
+/** @ingroup iface_zwp_pointer_gesture_swipe_v1 */
+static inline void *
+zwp_pointer_gesture_swipe_v1_get_user_data(struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_pointer_gesture_swipe_v1);
+}
+
+static inline uint32_t
+zwp_pointer_gesture_swipe_v1_get_version(struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_pointer_gesture_swipe_v1);
+}
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_swipe_v1
+ */
+static inline void
+zwp_pointer_gesture_swipe_v1_destroy(struct zwp_pointer_gesture_swipe_v1 *zwp_pointer_gesture_swipe_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_pointer_gesture_swipe_v1,
+			 ZWP_POINTER_GESTURE_SWIPE_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_pointer_gesture_swipe_v1);
+}
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ * @struct zwp_pointer_gesture_pinch_v1_listener
+ */
+struct zwp_pointer_gesture_pinch_v1_listener {
+	/**
+	 * multi-finger pinch begin
+	 *
+	 * This event is sent when a multi-finger pinch gesture is
+	 * detected on the device.
+	 * @param time timestamp with millisecond granularity
+	 * @param fingers number of fingers
+	 */
+	void (*begin)(void *data,
+		      struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1,
+		      uint32_t serial,
+		      uint32_t time,
+		      struct wl_surface *surface,
+		      uint32_t fingers);
+	/**
+	 * multi-finger pinch motion
+	 *
+	 * This event is sent when a multi-finger pinch gesture changes
+	 * the position of the logical center, the rotation or the relative
+	 * scale.
+	 *
+	 * The dx and dy coordinates are relative coordinates in the
+	 * surface coordinate space of the logical center of the gesture.
+	 *
+	 * The scale factor is an absolute scale compared to the
+	 * pointer_gesture_pinch.begin event, e.g. a scale of 2 means the
+	 * fingers are now twice as far apart as on
+	 * pointer_gesture_pinch.begin.
+	 *
+	 * The rotation is the relative angle in degrees clockwise compared
+	 * to the previous pointer_gesture_pinch.begin or
+	 * pointer_gesture_pinch.update event.
+	 * @param time timestamp with millisecond granularity
+	 * @param dx delta x coordinate in surface coordinate space
+	 * @param dy delta y coordinate in surface coordinate space
+	 * @param scale scale relative to the initial finger position
+	 * @param rotation angle in degrees cw relative to the previous event
+	 */
+	void (*update)(void *data,
+		       struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1,
+		       uint32_t time,
+		       wl_fixed_t dx,
+		       wl_fixed_t dy,
+		       wl_fixed_t scale,
+		       wl_fixed_t rotation);
+	/**
+	 * multi-finger pinch end
+	 *
+	 * This event is sent when a multi-finger pinch gesture ceases to
+	 * be valid. This may happen when one or more fingers are lifted or
+	 * the gesture is cancelled.
+	 *
+	 * When a gesture is cancelled, the client should undo state
+	 * changes caused by this gesture. What causes a gesture to be
+	 * cancelled is implementation-dependent.
+	 * @param time timestamp with millisecond granularity
+	 * @param cancelled 1 if the gesture was cancelled, 0 otherwise
+	 */
+	void (*end)(void *data,
+		    struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1,
+		    uint32_t serial,
+		    uint32_t time,
+		    int32_t cancelled);
+};
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ */
+static inline int
+zwp_pointer_gesture_pinch_v1_add_listener(struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1,
+					  const struct zwp_pointer_gesture_pinch_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_pointer_gesture_pinch_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_POINTER_GESTURE_PINCH_V1_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ */
+#define ZWP_POINTER_GESTURE_PINCH_V1_BEGIN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ */
+#define ZWP_POINTER_GESTURE_PINCH_V1_UPDATE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ */
+#define ZWP_POINTER_GESTURE_PINCH_V1_END_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ */
+#define ZWP_POINTER_GESTURE_PINCH_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_pointer_gesture_pinch_v1 */
+static inline void
+zwp_pointer_gesture_pinch_v1_set_user_data(struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_pointer_gesture_pinch_v1, user_data);
+}
+
+/** @ingroup iface_zwp_pointer_gesture_pinch_v1 */
+static inline void *
+zwp_pointer_gesture_pinch_v1_get_user_data(struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_pointer_gesture_pinch_v1);
+}
+
+static inline uint32_t
+zwp_pointer_gesture_pinch_v1_get_version(struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_pointer_gesture_pinch_v1);
+}
+
+/**
+ * @ingroup iface_zwp_pointer_gesture_pinch_v1
+ */
+static inline void
+zwp_pointer_gesture_pinch_v1_destroy(struct zwp_pointer_gesture_pinch_v1 *zwp_pointer_gesture_pinch_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_pointer_gesture_pinch_v1,
+			 ZWP_POINTER_GESTURE_PINCH_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_pointer_gesture_pinch_v1);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gdk/wayland/pointer-gestures-unstable-v1-protocol.c b/gdk/wayland/pointer-gestures-unstable-v1-protocol.c
new file mode 100755
index 0000000..ac6bbf6
--- /dev/null
+++ b/gdk/wayland/pointer-gestures-unstable-v1-protocol.c
@@ -0,0 +1,74 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_pointer_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zwp_pointer_gesture_pinch_v1_interface;
+extern const struct wl_interface zwp_pointer_gesture_swipe_v1_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&zwp_pointer_gesture_swipe_v1_interface,
+	&wl_pointer_interface,
+	&zwp_pointer_gesture_pinch_v1_interface,
+	&wl_pointer_interface,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+};
+
+static const struct wl_message zwp_pointer_gestures_v1_requests[] = {
+	{ "get_swipe_gesture", "no", types + 5 },
+	{ "get_pinch_gesture", "no", types + 7 },
+};
+
+const struct wl_interface zwp_pointer_gestures_v1_interface = {
+	"zwp_pointer_gestures_v1", 1,
+	2, zwp_pointer_gestures_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zwp_pointer_gesture_swipe_v1_requests[] = {
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_pointer_gesture_swipe_v1_events[] = {
+	{ "begin", "uuou", types + 9 },
+	{ "update", "uff", types + 0 },
+	{ "end", "uui", types + 0 },
+};
+
+const struct wl_interface zwp_pointer_gesture_swipe_v1_interface = {
+	"zwp_pointer_gesture_swipe_v1", 1,
+	1, zwp_pointer_gesture_swipe_v1_requests,
+	3, zwp_pointer_gesture_swipe_v1_events,
+};
+
+static const struct wl_message zwp_pointer_gesture_pinch_v1_requests[] = {
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_pointer_gesture_pinch_v1_events[] = {
+	{ "begin", "uuou", types + 13 },
+	{ "update", "uffff", types + 0 },
+	{ "end", "uui", types + 0 },
+};
+
+const struct wl_interface zwp_pointer_gesture_pinch_v1_interface = {
+	"zwp_pointer_gesture_pinch_v1", 1,
+	1, zwp_pointer_gesture_pinch_v1_requests,
+	3, zwp_pointer_gesture_pinch_v1_events,
+};
+
diff --git a/gdk/wayland/tablet-unstable-v2-client-protocol.h b/gdk/wayland/tablet-unstable-v2-client-protocol.h
new file mode 100755
index 0000000..75c5636
--- /dev/null
+++ b/gdk/wayland/tablet-unstable-v2-client-protocol.h
@@ -0,0 +1,2239 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef TABLET_UNSTABLE_V2_CLIENT_PROTOCOL_H
+#define TABLET_UNSTABLE_V2_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_tablet_unstable_v2 The tablet_unstable_v2 protocol
+ * Wayland protocol for graphics tablets
+ *
+ * @section page_desc_tablet_unstable_v2 Description
+ *
+ * This description provides a high-level overview of the interplay between
+ * the interfaces defined this protocol. For details, see the protocol
+ * specification.
+ *
+ * More than one tablet may exist, and device-specifics matter. Tablets are
+ * not represented by a single virtual device like wl_pointer. A client
+ * binds to the tablet manager object which is just a proxy object. From
+ * that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
+ * and that returns the actual interface that has all the tablets. With
+ * this indirection, we can avoid merging wp_tablet into the actual Wayland
+ * protocol, a long-term benefit.
+ *
+ * The wp_tablet_seat sends a "tablet added" event for each tablet
+ * connected. That event is followed by descriptive events about the
+ * hardware; currently that includes events for name, vid/pid and
+ * a wp_tablet.path event that describes a local path. This path can be
+ * used to uniquely identify a tablet or get more information through
+ * libwacom. Emulated or nested tablets can skip any of those, e.g. a
+ * virtual tablet may not have a vid/pid. The sequence of descriptive
+ * events is terminated by a wp_tablet.done event to signal that a client
+ * may now finalize any initialization for that tablet.
+ *
+ * Events from tablets require a tool in proximity. Tools are also managed
+ * by the tablet seat; a "tool added" event is sent whenever a tool is new
+ * to the compositor. That event is followed by a number of descriptive
+ * events about the hardware; currently that includes capabilities,
+ * hardware id and serial number, and tool type. Similar to the tablet
+ * interface, a wp_tablet_tool.done event is sent to terminate that initial
+ * sequence.
+ *
+ * Any event from a tool happens on the wp_tablet_tool interface. When the
+ * tool gets into proximity of the tablet, a proximity_in event is sent on
+ * the wp_tablet_tool interface, listing the tablet and the surface. That
+ * event is followed by a motion event with the coordinates. After that,
+ * it's the usual motion, axis, button, etc. events. The protocol's
+ * serialisation means events are grouped by wp_tablet_tool.frame events.
+ *
+ * Two special events (that don't exist in X) are down and up. They signal
+ * "tip touching the surface". For tablets without real proximity
+ * detection, the sequence is: proximity_in, motion, down, frame.
+ *
+ * When the tool leaves proximity, a proximity_out event is sent. If any
+ * button is still down, a button release event is sent before this
+ * proximity event. These button events are sent in the same frame as the
+ * proximity event to signal to the client that the buttons were held when
+ * the tool left proximity.
+ *
+ * If the tool moves out of the surface but stays in proximity (i.e.
+ * between windows), compositor-specific grab policies apply. This usually
+ * means that the proximity-out is delayed until all buttons are released.
+ *
+ * Moving a tool physically from one tablet to the other has no real effect
+ * on the protocol, since we already have the tool object from the "tool
+ * added" event. All the information is already there and the proximity
+ * events on both tablets are all a client needs to reconstruct what
+ * happened.
+ *
+ * Some extra axes are normalized, i.e. the client knows the range as
+ * specified in the protocol (e.g. [0, 65535]), the granularity however is
+ * unknown. The current normalized axes are pressure, distance, and slider.
+ *
+ * Other extra axes are in physical units as specified in the protocol.
+ * The current extra axes with physical units are tilt, rotation and
+ * wheel rotation.
+ *
+ * Since tablets work independently of the pointer controlled by the mouse,
+ * the focus handling is independent too and controlled by proximity.
+ * The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
+ * This cursor surface may be the same as the mouse cursor, and it may be
+ * the same across tools but it is possible to be more fine-grained. For
+ * example, a client may set different cursors for the pen and eraser.
+ *
+ * Tools are generally independent of tablets and it is
+ * compositor-specific policy when a tool can be removed. Common approaches
+ * will likely include some form of removing a tool when all tablets the
+ * tool was used on are removed.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ *
+ * @section page_ifaces_tablet_unstable_v2 Interfaces
+ * - @subpage page_iface_zwp_tablet_manager_v2 - controller object for graphic tablet devices
+ * - @subpage page_iface_zwp_tablet_seat_v2 - controller object for graphic tablet devices of a seat
+ * - @subpage page_iface_zwp_tablet_tool_v2 - a physical tablet tool
+ * - @subpage page_iface_zwp_tablet_v2 - graphics tablet device
+ * - @subpage page_iface_zwp_tablet_pad_ring_v2 - pad ring
+ * - @subpage page_iface_zwp_tablet_pad_strip_v2 - pad strip
+ * - @subpage page_iface_zwp_tablet_pad_group_v2 - a set of buttons, rings and strips
+ * - @subpage page_iface_zwp_tablet_pad_v2 - a set of buttons, rings and strips
+ * @section page_copyright_tablet_unstable_v2 Copyright
+ * <pre>
+ *
+ * Copyright 2014 © Stephen "Lyude" Chandler Paul
+ * Copyright 2015-2016 © Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * </pre>
+ */
+struct wl_seat;
+struct wl_surface;
+struct zwp_tablet_manager_v2;
+struct zwp_tablet_pad_group_v2;
+struct zwp_tablet_pad_ring_v2;
+struct zwp_tablet_pad_strip_v2;
+struct zwp_tablet_pad_v2;
+struct zwp_tablet_seat_v2;
+struct zwp_tablet_tool_v2;
+struct zwp_tablet_v2;
+
+/**
+ * @page page_iface_zwp_tablet_manager_v2 zwp_tablet_manager_v2
+ * @section page_iface_zwp_tablet_manager_v2_desc Description
+ *
+ * An object that provides access to the graphics tablets available on this
+ * system. All tablets are associated with a seat, to get access to the
+ * actual tablets, use wp_tablet_manager.get_tablet_seat.
+ * @section page_iface_zwp_tablet_manager_v2_api API
+ * See @ref iface_zwp_tablet_manager_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_manager_v2 The zwp_tablet_manager_v2 interface
+ *
+ * An object that provides access to the graphics tablets available on this
+ * system. All tablets are associated with a seat, to get access to the
+ * actual tablets, use wp_tablet_manager.get_tablet_seat.
+ */
+extern const struct wl_interface zwp_tablet_manager_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_seat_v2 zwp_tablet_seat_v2
+ * @section page_iface_zwp_tablet_seat_v2_desc Description
+ *
+ * An object that provides access to the graphics tablets available on this
+ * seat. After binding to this interface, the compositor sends a set of
+ * wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
+ * @section page_iface_zwp_tablet_seat_v2_api API
+ * See @ref iface_zwp_tablet_seat_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_seat_v2 The zwp_tablet_seat_v2 interface
+ *
+ * An object that provides access to the graphics tablets available on this
+ * seat. After binding to this interface, the compositor sends a set of
+ * wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
+ */
+extern const struct wl_interface zwp_tablet_seat_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_tool_v2 zwp_tablet_tool_v2
+ * @section page_iface_zwp_tablet_tool_v2_desc Description
+ *
+ * An object that represents a physical tool that has been, or is
+ * currently in use with a tablet in this seat. Each wp_tablet_tool
+ * object stays valid until the client destroys it; the compositor
+ * reuses the wp_tablet_tool object to indicate that the object's
+ * respective physical tool has come into proximity of a tablet again.
+ *
+ * A wp_tablet_tool object's relation to a physical tool depends on the
+ * tablet's ability to report serial numbers. If the tablet supports
+ * this capability, then the object represents a specific physical tool
+ * and can be identified even when used on multiple tablets.
+ *
+ * A tablet tool has a number of static characteristics, e.g. tool type,
+ * hardware_serial and capabilities. These capabilities are sent in an
+ * event sequence after the wp_tablet_seat.tool_added event before any
+ * actual events from this tool. This initial event sequence is
+ * terminated by a wp_tablet_tool.done event.
+ *
+ * Tablet tool events are grouped by wp_tablet_tool.frame events.
+ * Any events received before a wp_tablet_tool.frame event should be
+ * considered part of the same hardware state change.
+ * @section page_iface_zwp_tablet_tool_v2_api API
+ * See @ref iface_zwp_tablet_tool_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_tool_v2 The zwp_tablet_tool_v2 interface
+ *
+ * An object that represents a physical tool that has been, or is
+ * currently in use with a tablet in this seat. Each wp_tablet_tool
+ * object stays valid until the client destroys it; the compositor
+ * reuses the wp_tablet_tool object to indicate that the object's
+ * respective physical tool has come into proximity of a tablet again.
+ *
+ * A wp_tablet_tool object's relation to a physical tool depends on the
+ * tablet's ability to report serial numbers. If the tablet supports
+ * this capability, then the object represents a specific physical tool
+ * and can be identified even when used on multiple tablets.
+ *
+ * A tablet tool has a number of static characteristics, e.g. tool type,
+ * hardware_serial and capabilities. These capabilities are sent in an
+ * event sequence after the wp_tablet_seat.tool_added event before any
+ * actual events from this tool. This initial event sequence is
+ * terminated by a wp_tablet_tool.done event.
+ *
+ * Tablet tool events are grouped by wp_tablet_tool.frame events.
+ * Any events received before a wp_tablet_tool.frame event should be
+ * considered part of the same hardware state change.
+ */
+extern const struct wl_interface zwp_tablet_tool_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_v2 zwp_tablet_v2
+ * @section page_iface_zwp_tablet_v2_desc Description
+ *
+ * The wp_tablet interface represents one graphics tablet device. The
+ * tablet interface itself does not generate events; all events are
+ * generated by wp_tablet_tool objects when in proximity above a tablet.
+ *
+ * A tablet has a number of static characteristics, e.g. device name and
+ * pid/vid. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.tablet_added event. This initial event sequence is
+ * terminated by a wp_tablet.done event.
+ * @section page_iface_zwp_tablet_v2_api API
+ * See @ref iface_zwp_tablet_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_v2 The zwp_tablet_v2 interface
+ *
+ * The wp_tablet interface represents one graphics tablet device. The
+ * tablet interface itself does not generate events; all events are
+ * generated by wp_tablet_tool objects when in proximity above a tablet.
+ *
+ * A tablet has a number of static characteristics, e.g. device name and
+ * pid/vid. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.tablet_added event. This initial event sequence is
+ * terminated by a wp_tablet.done event.
+ */
+extern const struct wl_interface zwp_tablet_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_pad_ring_v2 zwp_tablet_pad_ring_v2
+ * @section page_iface_zwp_tablet_pad_ring_v2_desc Description
+ *
+ * A circular interaction area, such as the touch ring on the Wacom Intuos
+ * Pro series tablets.
+ *
+ * Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
+ * event.
+ * @section page_iface_zwp_tablet_pad_ring_v2_api API
+ * See @ref iface_zwp_tablet_pad_ring_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_ring_v2 The zwp_tablet_pad_ring_v2 interface
+ *
+ * A circular interaction area, such as the touch ring on the Wacom Intuos
+ * Pro series tablets.
+ *
+ * Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
+ * event.
+ */
+extern const struct wl_interface zwp_tablet_pad_ring_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_pad_strip_v2 zwp_tablet_pad_strip_v2
+ * @section page_iface_zwp_tablet_pad_strip_v2_desc Description
+ *
+ * A linear interaction area, such as the strips found in Wacom Cintiq
+ * models.
+ *
+ * Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
+ * event.
+ * @section page_iface_zwp_tablet_pad_strip_v2_api API
+ * See @ref iface_zwp_tablet_pad_strip_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_strip_v2 The zwp_tablet_pad_strip_v2 interface
+ *
+ * A linear interaction area, such as the strips found in Wacom Cintiq
+ * models.
+ *
+ * Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
+ * event.
+ */
+extern const struct wl_interface zwp_tablet_pad_strip_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_pad_group_v2 zwp_tablet_pad_group_v2
+ * @section page_iface_zwp_tablet_pad_group_v2_desc Description
+ *
+ * A pad group describes a distinct (sub)set of buttons, rings and strips
+ * present in the tablet. The criteria of this grouping is usually positional,
+ * eg. if a tablet has buttons on the left and right side, 2 groups will be
+ * presented. The physical arrangement of groups is undisclosed and may
+ * change on the fly.
+ *
+ * Pad groups will announce their features during pad initialization. Between
+ * the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
+ * pad group will announce the buttons, rings and strips contained in it,
+ * plus the number of supported modes.
+ *
+ * Modes are a mechanism to allow multiple groups of actions for every element
+ * in the pad group. The number of groups and available modes in each is
+ * persistent across device plugs. The current mode is user-switchable, it
+ * will be announced through the wp_tablet_pad_group.mode_switch event both
+ * whenever it is switched, and after wp_tablet_pad.enter.
+ *
+ * The current mode logically applies to all elements in the pad group,
+ * although it is at clients' discretion whether to actually perform different
+ * actions, and/or issue the respective .set_feedback requests to notify the
+ * compositor. See the wp_tablet_pad_group.mode_switch event for more details.
+ * @section page_iface_zwp_tablet_pad_group_v2_api API
+ * See @ref iface_zwp_tablet_pad_group_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_group_v2 The zwp_tablet_pad_group_v2 interface
+ *
+ * A pad group describes a distinct (sub)set of buttons, rings and strips
+ * present in the tablet. The criteria of this grouping is usually positional,
+ * eg. if a tablet has buttons on the left and right side, 2 groups will be
+ * presented. The physical arrangement of groups is undisclosed and may
+ * change on the fly.
+ *
+ * Pad groups will announce their features during pad initialization. Between
+ * the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
+ * pad group will announce the buttons, rings and strips contained in it,
+ * plus the number of supported modes.
+ *
+ * Modes are a mechanism to allow multiple groups of actions for every element
+ * in the pad group. The number of groups and available modes in each is
+ * persistent across device plugs. The current mode is user-switchable, it
+ * will be announced through the wp_tablet_pad_group.mode_switch event both
+ * whenever it is switched, and after wp_tablet_pad.enter.
+ *
+ * The current mode logically applies to all elements in the pad group,
+ * although it is at clients' discretion whether to actually perform different
+ * actions, and/or issue the respective .set_feedback requests to notify the
+ * compositor. See the wp_tablet_pad_group.mode_switch event for more details.
+ */
+extern const struct wl_interface zwp_tablet_pad_group_v2_interface;
+/**
+ * @page page_iface_zwp_tablet_pad_v2 zwp_tablet_pad_v2
+ * @section page_iface_zwp_tablet_pad_v2_desc Description
+ *
+ * A pad device is a set of buttons, rings and strips
+ * usually physically present on the tablet device itself. Some
+ * exceptions exist where the pad device is physically detached, e.g. the
+ * Wacom ExpressKey Remote.
+ *
+ * Pad devices have no axes that control the cursor and are generally
+ * auxiliary devices to the tool devices used on the tablet surface.
+ *
+ * A pad device has a number of static characteristics, e.g. the number
+ * of rings. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.pad_added event before any actual events from this pad.
+ * This initial event sequence is terminated by a wp_tablet_pad.done
+ * event.
+ *
+ * All pad features (buttons, rings and strips) are logically divided into
+ * groups and all pads have at least one group. The available groups are
+ * notified through the wp_tablet_pad.group event; the compositor will
+ * emit one event per group before emitting wp_tablet_pad.done.
+ *
+ * Groups may have multiple modes. Modes allow clients to map multiple
+ * actions to a single pad feature. Only one mode can be active per group,
+ * although different groups may have different active modes.
+ * @section page_iface_zwp_tablet_pad_v2_api API
+ * See @ref iface_zwp_tablet_pad_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_v2 The zwp_tablet_pad_v2 interface
+ *
+ * A pad device is a set of buttons, rings and strips
+ * usually physically present on the tablet device itself. Some
+ * exceptions exist where the pad device is physically detached, e.g. the
+ * Wacom ExpressKey Remote.
+ *
+ * Pad devices have no axes that control the cursor and are generally
+ * auxiliary devices to the tool devices used on the tablet surface.
+ *
+ * A pad device has a number of static characteristics, e.g. the number
+ * of rings. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.pad_added event before any actual events from this pad.
+ * This initial event sequence is terminated by a wp_tablet_pad.done
+ * event.
+ *
+ * All pad features (buttons, rings and strips) are logically divided into
+ * groups and all pads have at least one group. The available groups are
+ * notified through the wp_tablet_pad.group event; the compositor will
+ * emit one event per group before emitting wp_tablet_pad.done.
+ *
+ * Groups may have multiple modes. Modes allow clients to map multiple
+ * actions to a single pad feature. Only one mode can be active per group,
+ * although different groups may have different active modes.
+ */
+extern const struct wl_interface zwp_tablet_pad_v2_interface;
+
+#define ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT 0
+#define ZWP_TABLET_MANAGER_V2_DESTROY 1
+
+
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ */
+#define ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ */
+#define ZWP_TABLET_MANAGER_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_manager_v2 */
+static inline void
+zwp_tablet_manager_v2_set_user_data(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_manager_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_manager_v2 */
+static inline void *
+zwp_tablet_manager_v2_get_user_data(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_manager_v2);
+}
+
+static inline uint32_t
+zwp_tablet_manager_v2_get_version(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_manager_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ *
+ * Get the wp_tablet_seat object for the given seat. This object
+ * provides access to all graphics tablets in this seat.
+ */
+static inline struct zwp_tablet_seat_v2 *
+zwp_tablet_manager_v2_get_tablet_seat(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2, struct wl_seat *seat)
+{
+	struct wl_proxy *tablet_seat;
+
+	tablet_seat = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_tablet_manager_v2,
+			 ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT, &zwp_tablet_seat_v2_interface, NULL, seat);
+
+	return (struct zwp_tablet_seat_v2 *) tablet_seat;
+}
+
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ *
+ * Destroy the wp_tablet_manager object. Objects created from this
+ * object are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_manager_v2_destroy(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_manager_v2,
+			 ZWP_TABLET_MANAGER_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_manager_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ * @struct zwp_tablet_seat_v2_listener
+ */
+struct zwp_tablet_seat_v2_listener {
+	/**
+	 * new device notification
+	 *
+	 * This event is sent whenever a new tablet becomes available on
+	 * this seat. This event only provides the object id of the tablet,
+	 * any static information about the tablet (device name, vid/pid,
+	 * etc.) is sent through the wp_tablet interface.
+	 * @param id the newly added graphics tablet
+	 */
+	void (*tablet_added)(void *data,
+			     struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+			     struct zwp_tablet_v2 *id);
+	/**
+	 * a new tool has been used with a tablet
+	 *
+	 * This event is sent whenever a tool that has not previously
+	 * been used with a tablet comes into use. This event only provides
+	 * the object id of the tool; any static information about the tool
+	 * (capabilities, type, etc.) is sent through the wp_tablet_tool
+	 * interface.
+	 * @param id the newly added tablet tool
+	 */
+	void (*tool_added)(void *data,
+			   struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+			   struct zwp_tablet_tool_v2 *id);
+	/**
+	 * new pad notification
+	 *
+	 * This event is sent whenever a new pad is known to the system.
+	 * Typically, pads are physically attached to tablets and a
+	 * pad_added event is sent immediately after the
+	 * wp_tablet_seat.tablet_added. However, some standalone pad
+	 * devices logically attach to tablets at runtime, and the client
+	 * must wait for wp_tablet_pad.enter to know the tablet a pad is
+	 * attached to.
+	 *
+	 * This event only provides the object id of the pad. All further
+	 * features (buttons, strips, rings) are sent through the
+	 * wp_tablet_pad interface.
+	 * @param id the newly added pad
+	 */
+	void (*pad_added)(void *data,
+			  struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+			  struct zwp_tablet_pad_v2 *id);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+static inline int
+zwp_tablet_seat_v2_add_listener(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+				const struct zwp_tablet_seat_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_seat_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_SEAT_V2_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_TABLET_ADDED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_TOOL_ADDED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_PAD_ADDED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_seat_v2 */
+static inline void
+zwp_tablet_seat_v2_set_user_data(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_seat_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_seat_v2 */
+static inline void *
+zwp_tablet_seat_v2_get_user_data(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_seat_v2);
+}
+
+static inline uint32_t
+zwp_tablet_seat_v2_get_version(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_seat_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ *
+ * Destroy the wp_tablet_seat object. Objects created from this
+ * object are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_seat_v2_destroy(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_seat_v2,
+			 ZWP_TABLET_SEAT_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_seat_v2);
+}
+
+#ifndef ZWP_TABLET_TOOL_V2_TYPE_ENUM
+#define ZWP_TABLET_TOOL_V2_TYPE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * a physical tool type
+ *
+ * Describes the physical type of a tool. The physical type of a tool
+ * generally defines its base usage.
+ *
+ * The mouse tool represents a mouse-shaped tool that is not a relative
+ * device but bound to the tablet's surface, providing absolute
+ * coordinates.
+ *
+ * The lens tool is a mouse-shaped tool with an attached lens to
+ * provide precision focus.
+ */
+enum zwp_tablet_tool_v2_type {
+	/**
+	 * Pen
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_PEN = 0x140,
+	/**
+	 * Eraser
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_ERASER = 0x141,
+	/**
+	 * Brush
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_BRUSH = 0x142,
+	/**
+	 * Pencil
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_PENCIL = 0x143,
+	/**
+	 * Airbrush
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_AIRBRUSH = 0x144,
+	/**
+	 * Finger
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_FINGER = 0x145,
+	/**
+	 * Mouse
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_MOUSE = 0x146,
+	/**
+	 * Lens
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_LENS = 0x147,
+};
+#endif /* ZWP_TABLET_TOOL_V2_TYPE_ENUM */
+
+#ifndef ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM
+#define ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * capability flags for a tool
+ *
+ * Describes extra capabilities on a tablet.
+ *
+ * Any tool must provide x and y values, extra axes are
+ * device-specific.
+ */
+enum zwp_tablet_tool_v2_capability {
+	/**
+	 * Tilt axes
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_TILT = 1,
+	/**
+	 * Pressure axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_PRESSURE = 2,
+	/**
+	 * Distance axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_DISTANCE = 3,
+	/**
+	 * Z-rotation axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_ROTATION = 4,
+	/**
+	 * Slider axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_SLIDER = 5,
+	/**
+	 * Wheel axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_WHEEL = 6,
+};
+#endif /* ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM */
+
+#ifndef ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM
+#define ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * physical button state
+ *
+ * Describes the physical state of a button that produced the button event.
+ */
+enum zwp_tablet_tool_v2_button_state {
+	/**
+	 * button is not pressed
+	 */
+	ZWP_TABLET_TOOL_V2_BUTTON_STATE_RELEASED = 0,
+	/**
+	 * button is pressed
+	 */
+	ZWP_TABLET_TOOL_V2_BUTTON_STATE_PRESSED = 1,
+};
+#endif /* ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM */
+
+#ifndef ZWP_TABLET_TOOL_V2_ERROR_ENUM
+#define ZWP_TABLET_TOOL_V2_ERROR_ENUM
+enum zwp_tablet_tool_v2_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	ZWP_TABLET_TOOL_V2_ERROR_ROLE = 0,
+};
+#endif /* ZWP_TABLET_TOOL_V2_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * @struct zwp_tablet_tool_v2_listener
+ */
+struct zwp_tablet_tool_v2_listener {
+	/**
+	 * tool type
+	 *
+	 * The tool type is the high-level type of the tool and usually
+	 * decides the interaction expected from this tool.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param tool_type the physical tool type
+	 */
+	void (*type)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		     uint32_t tool_type);
+	/**
+	 * unique hardware serial number of the tool
+	 *
+	 * If the physical tool can be identified by a unique 64-bit
+	 * serial number, this event notifies the client of this serial
+	 * number.
+	 *
+	 * If multiple tablets are available in the same seat and the tool
+	 * is uniquely identifiable by the serial number, that tool may
+	 * move between tablets.
+	 *
+	 * Otherwise, if the tool has no serial number and this event is
+	 * missing, the tool is tied to the tablet it first comes into
+	 * proximity with. Even if the physical tool is used on multiple
+	 * tablets, separate wp_tablet_tool objects will be created, one
+	 * per tablet.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param hardware_serial_hi the unique serial number of the tool, most significant bits
+	 * @param hardware_serial_lo the unique serial number of the tool, least significant bits
+	 */
+	void (*hardware_serial)(void *data,
+				struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+				uint32_t hardware_serial_hi,
+				uint32_t hardware_serial_lo);
+	/**
+	 * hardware id notification in Wacom's format
+	 *
+	 * This event notifies the client of a hardware id available on
+	 * this tool.
+	 *
+	 * The hardware id is a device-specific 64-bit id that provides
+	 * extra information about the tool in use, beyond the wl_tool.type
+	 * enumeration. The format of the id is specific to tablets made by
+	 * Wacom Inc. For example, the hardware id of a Wacom Grip Pen (a
+	 * stylus) is 0x802.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param hardware_id_hi the hardware id, most significant bits
+	 * @param hardware_id_lo the hardware id, least significant bits
+	 */
+	void (*hardware_id_wacom)(void *data,
+				  struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+				  uint32_t hardware_id_hi,
+				  uint32_t hardware_id_lo);
+	/**
+	 * tool capability notification
+	 *
+	 * This event notifies the client of any capabilities of this
+	 * tool, beyond the main set of x/y axes and tip up/down detection.
+	 *
+	 * One event is sent for each extra capability available on this
+	 * tool.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param capability the capability
+	 */
+	void (*capability)(void *data,
+			   struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			   uint32_t capability);
+	/**
+	 * tool description events sequence complete
+	 *
+	 * This event signals the end of the initial burst of descriptive
+	 * events. A client may consider the static description of the tool
+	 * to be complete and finalize initialization of the tool.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * tool removed
+	 *
+	 * This event is sent when the tool is removed from the system
+	 * and will send no further events. Should the physical tool come
+	 * back into proximity later, a new wp_tablet_tool object will be
+	 * created.
+	 *
+	 * It is compositor-dependent when a tool is removed. A compositor
+	 * may remove a tool on proximity out, tablet removal or any other
+	 * reason. A compositor may also keep a tool alive until shutdown.
+	 *
+	 * If the tool is currently in proximity, a proximity_out event
+	 * will be sent before the removed event. See
+	 * wp_tablet_tool.proximity_out for the handling of any buttons
+	 * logically down.
+	 *
+	 * When this event is received, the client must
+	 * wp_tablet_tool.destroy the object.
+	 */
+	void (*removed)(void *data,
+			struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * proximity in event
+	 *
+	 * Notification that this tool is focused on a certain surface.
+	 *
+	 * This event can be received when the tool has moved from one
+	 * surface to another, or when the tool has come back into
+	 * proximity above the surface.
+	 *
+	 * If any button is logically down when the tool comes into
+	 * proximity, the respective button event is sent after the
+	 * proximity_in event but within the same frame as the proximity_in
+	 * event.
+	 * @param tablet The tablet the tool is in proximity of
+	 * @param surface The current surface the tablet tool is over
+	 */
+	void (*proximity_in)(void *data,
+			     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			     uint32_t serial,
+			     struct zwp_tablet_v2 *tablet,
+			     struct wl_surface *surface);
+	/**
+	 * proximity out event
+	 *
+	 * Notification that this tool has either left proximity, or is
+	 * no longer focused on a certain surface.
+	 *
+	 * When the tablet tool leaves proximity of the tablet, button
+	 * release events are sent for each button that was held down at
+	 * the time of leaving proximity. These events are sent before the
+	 * proximity_out event but within the same wp_tablet.frame.
+	 *
+	 * If the tool stays within proximity of the tablet, but the focus
+	 * changes from one surface to another, a button release event may
+	 * not be sent until the button is actually released or the tool
+	 * leaves the proximity of the tablet.
+	 */
+	void (*proximity_out)(void *data,
+			      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * tablet tool is making contact
+	 *
+	 * Sent whenever the tablet tool comes in contact with the
+	 * surface of the tablet.
+	 *
+	 * If the tool is already in contact with the tablet when entering
+	 * the input region, the client owning said region will receive a
+	 * wp_tablet.proximity_in event, followed by a wp_tablet.down event
+	 * and a wp_tablet.frame event.
+	 *
+	 * Note that this event describes logical contact, not physical
+	 * contact. On some devices, a compositor may not consider a tool
+	 * in logical contact until a minimum physical pressure threshold
+	 * is exceeded.
+	 */
+	void (*down)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		     uint32_t serial);
+	/**
+	 * tablet tool is no longer making contact
+	 *
+	 * Sent whenever the tablet tool stops making contact with the
+	 * surface of the tablet, or when the tablet tool moves out of the
+	 * input region and the compositor grab (if any) is dismissed.
+	 *
+	 * If the tablet tool moves out of the input region while in
+	 * contact with the surface of the tablet and the compositor does
+	 * not have an ongoing grab on the surface, the client owning said
+	 * region will receive a wp_tablet.up event, followed by a
+	 * wp_tablet.proximity_out event and a wp_tablet.frame event. If
+	 * the compositor has an ongoing grab on this device, this event
+	 * sequence is sent whenever the grab is dismissed in the future.
+	 *
+	 * Note that this event describes logical contact, not physical
+	 * contact. On some devices, a compositor may not consider a tool
+	 * out of logical contact until physical pressure falls below a
+	 * specific threshold.
+	 */
+	void (*up)(void *data,
+		   struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * motion event
+	 *
+	 * Sent whenever a tablet tool moves.
+	 * @param x surface-local x coordinate
+	 * @param y surface-local y coordinate
+	 */
+	void (*motion)(void *data,
+		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		       wl_fixed_t x,
+		       wl_fixed_t y);
+	/**
+	 * pressure change event
+	 *
+	 * Sent whenever the pressure axis on a tool changes. The value
+	 * of this event is normalized to a value between 0 and 65535.
+	 *
+	 * Note that pressure may be nonzero even when a tool is not in
+	 * logical contact. See the down and up events for more details.
+	 * @param pressure The current pressure value
+	 */
+	void (*pressure)(void *data,
+			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			 uint32_t pressure);
+	/**
+	 * distance change event
+	 *
+	 * Sent whenever the distance axis on a tool changes. The value
+	 * of this event is normalized to a value between 0 and 65535.
+	 *
+	 * Note that distance may be nonzero even when a tool is not in
+	 * logical contact. See the down and up events for more details.
+	 * @param distance The current distance value
+	 */
+	void (*distance)(void *data,
+			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			 uint32_t distance);
+	/**
+	 * tilt change event
+	 *
+	 * Sent whenever one or both of the tilt axes on a tool change.
+	 * Each tilt value is in degrees, relative to the z-axis of the
+	 * tablet. The angle is positive when the top of a tool tilts along
+	 * the positive x or y axis.
+	 * @param tilt_x The current value of the X tilt axis
+	 * @param tilt_y The current value of the Y tilt axis
+	 */
+	void (*tilt)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		     wl_fixed_t tilt_x,
+		     wl_fixed_t tilt_y);
+	/**
+	 * z-rotation change event
+	 *
+	 * Sent whenever the z-rotation axis on the tool changes. The
+	 * rotation value is in degrees clockwise from the tool's logical
+	 * neutral position.
+	 * @param degrees The current rotation of the Z axis
+	 */
+	void (*rotation)(void *data,
+			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			 wl_fixed_t degrees);
+	/**
+	 * Slider position change event
+	 *
+	 * Sent whenever the slider position on the tool changes. The
+	 * value is normalized between -65535 and 65535, with 0 as the
+	 * logical neutral position of the slider.
+	 *
+	 * The slider is available on e.g. the Wacom Airbrush tool.
+	 * @param position The current position of slider
+	 */
+	void (*slider)(void *data,
+		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		       int32_t position);
+	/**
+	 * Wheel delta event
+	 *
+	 * Sent whenever the wheel on the tool emits an event. This event
+	 * contains two values for the same axis change. The degrees value
+	 * is in the same orientation as the wl_pointer.vertical_scroll
+	 * axis. The clicks value is in discrete logical clicks of the
+	 * mouse wheel. This value may be zero if the movement of the wheel
+	 * was less than one logical click.
+	 *
+	 * Clients should choose either value and avoid mixing degrees and
+	 * clicks. The compositor may accumulate values smaller than a
+	 * logical click and emulate click events when a certain threshold
+	 * is met. Thus, wl_tablet_tool.wheel events with non-zero clicks
+	 * values may have different degrees values.
+	 * @param degrees The wheel delta in degrees
+	 * @param clicks The wheel delta in discrete clicks
+	 */
+	void (*wheel)(void *data,
+		      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		      wl_fixed_t degrees,
+		      int32_t clicks);
+	/**
+	 * button event
+	 *
+	 * Sent whenever a button on the tool is pressed or released.
+	 *
+	 * If a button is held down when the tool moves in or out of
+	 * proximity, button events are generated by the compositor. See
+	 * wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
+	 * details.
+	 * @param button The button whose state has changed
+	 * @param state Whether the button was pressed or released
+	 */
+	void (*button)(void *data,
+		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		       uint32_t serial,
+		       uint32_t button,
+		       uint32_t state);
+	/**
+	 * frame event
+	 *
+	 * Marks the end of a series of axis and/or button updates from
+	 * the tablet. The Wayland protocol requires axis updates to be
+	 * sent sequentially, however all events within a frame should be
+	 * considered one hardware event.
+	 * @param time The time of the event with millisecond granularity
+	 */
+	void (*frame)(void *data,
+		      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		      uint32_t time);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+static inline int
+zwp_tablet_tool_v2_add_listener(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+				const struct zwp_tablet_tool_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_tool_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_TOOL_V2_SET_CURSOR 0
+#define ZWP_TABLET_TOOL_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_TYPE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_HARDWARE_SERIAL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_HARDWARE_ID_WACOM_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_CAPABILITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_REMOVED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_PROXIMITY_IN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_PROXIMITY_OUT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DOWN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_UP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_MOTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_PRESSURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DISTANCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_TILT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_ROTATION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_SLIDER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_WHEEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_BUTTON_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_FRAME_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_SET_CURSOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_tool_v2 */
+static inline void
+zwp_tablet_tool_v2_set_user_data(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_tool_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_tool_v2 */
+static inline void *
+zwp_tablet_tool_v2_get_user_data(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_tool_v2);
+}
+
+static inline uint32_t
+zwp_tablet_tool_v2_get_version(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_tool_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ *
+ * Sets the surface of the cursor used for this tool on the given
+ * tablet. This request only takes effect if the tool is in proximity
+ * of one of the requesting client's surfaces or the surface parameter
+ * is the current pointer surface. If there was a previous surface set
+ * with this request it is replaced. If surface is NULL, the cursor
+ * image is hidden.
+ *
+ * The parameters hotspot_x and hotspot_y define the position of the
+ * pointer surface relative to the pointer location. Its top-left corner
+ * is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
+ * coordinates of the pointer location, in surface-local coordinates.
+ *
+ * On surface.attach requests to the pointer surface, hotspot_x and
+ * hotspot_y are decremented by the x and y parameters passed to the
+ * request. Attach must be confirmed by wl_surface.commit as usual.
+ *
+ * The hotspot can also be updated by passing the currently set pointer
+ * surface to this request with new values for hotspot_x and hotspot_y.
+ *
+ * The current and pending input regions of the wl_surface are cleared,
+ * and wl_surface.set_input_region is ignored until the wl_surface is no
+ * longer used as the cursor. When the use as a cursor ends, the current
+ * and pending input regions become undefined, and the wl_surface is
+ * unmapped.
+ *
+ * This request gives the surface the role of a wp_tablet_tool cursor. A
+ * surface may only ever be used as the cursor surface for one
+ * wp_tablet_tool. If the surface already has another role or has
+ * previously been used as cursor surface for a different tool, a
+ * protocol error is raised.
+ */
+static inline void
+zwp_tablet_tool_v2_set_cursor(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2, uint32_t serial, struct wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_tool_v2,
+			 ZWP_TABLET_TOOL_V2_SET_CURSOR, serial, surface, hotspot_x, hotspot_y);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ *
+ * This destroys the client's resource for this tool object.
+ */
+static inline void
+zwp_tablet_tool_v2_destroy(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_tool_v2,
+			 ZWP_TABLET_TOOL_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_tool_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ * @struct zwp_tablet_v2_listener
+ */
+struct zwp_tablet_v2_listener {
+	/**
+	 * tablet device name
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet.done event.
+	 * @param name the device name
+	 */
+	void (*name)(void *data,
+		     struct zwp_tablet_v2 *zwp_tablet_v2,
+		     const char *name);
+	/**
+	 * tablet device USB vendor/product id
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet.done event.
+	 * @param vid USB vendor id
+	 * @param pid USB product id
+	 */
+	void (*id)(void *data,
+		   struct zwp_tablet_v2 *zwp_tablet_v2,
+		   uint32_t vid,
+		   uint32_t pid);
+	/**
+	 * path to the device
+	 *
+	 * A system-specific device path that indicates which device is
+	 * behind this wp_tablet. This information may be used to gather
+	 * additional information about the device, e.g. through libwacom.
+	 *
+	 * A device may have more than one device path. If so, multiple
+	 * wp_tablet.path events are sent. A device may be emulated and not
+	 * have a device path, and in that case this event will not be
+	 * sent.
+	 *
+	 * The format of the path is unspecified, it may be a device node,
+	 * a sysfs path, or some other identifier. It is up to the client
+	 * to identify the string provided.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet.done event.
+	 * @param path path to local device
+	 */
+	void (*path)(void *data,
+		     struct zwp_tablet_v2 *zwp_tablet_v2,
+		     const char *path);
+	/**
+	 * tablet description events sequence complete
+	 *
+	 * This event is sent immediately to signal the end of the
+	 * initial burst of descriptive events. A client may consider the
+	 * static description of the tablet to be complete and finalize
+	 * initialization of the tablet.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_v2 *zwp_tablet_v2);
+	/**
+	 * tablet removed event
+	 *
+	 * Sent when the tablet has been removed from the system. When a
+	 * tablet is removed, some tools may be removed.
+	 *
+	 * When this event is received, the client must wp_tablet.destroy
+	 * the object.
+	 */
+	void (*removed)(void *data,
+			struct zwp_tablet_v2 *zwp_tablet_v2);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+static inline int
+zwp_tablet_v2_add_listener(struct zwp_tablet_v2 *zwp_tablet_v2,
+			   const struct zwp_tablet_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_V2_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_NAME_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_PATH_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_REMOVED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_v2 */
+static inline void
+zwp_tablet_v2_set_user_data(struct zwp_tablet_v2 *zwp_tablet_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_v2 */
+static inline void *
+zwp_tablet_v2_get_user_data(struct zwp_tablet_v2 *zwp_tablet_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_v2);
+}
+
+static inline uint32_t
+zwp_tablet_v2_get_version(struct zwp_tablet_v2 *zwp_tablet_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ *
+ * This destroys the client's resource for this tablet object.
+ */
+static inline void
+zwp_tablet_v2_destroy(struct zwp_tablet_v2 *zwp_tablet_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_v2,
+			 ZWP_TABLET_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_v2);
+}
+
+#ifndef ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM
+#define ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ * ring axis source
+ *
+ * Describes the source types for ring events. This indicates to the
+ * client how a ring event was physically generated; a client may
+ * adjust the user interface accordingly. For example, events
+ * from a "finger" source may trigger kinetic scrolling.
+ */
+enum zwp_tablet_pad_ring_v2_source {
+	/**
+	 * finger
+	 */
+	ZWP_TABLET_PAD_RING_V2_SOURCE_FINGER = 1,
+};
+#endif /* ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ * @struct zwp_tablet_pad_ring_v2_listener
+ */
+struct zwp_tablet_pad_ring_v2_listener {
+	/**
+	 * ring event source
+	 *
+	 * Source information for ring events.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wp_tablet_pad_ring.frame event and carries the source
+	 * information for all events within that frame.
+	 *
+	 * The source specifies how this event was generated. If the source
+	 * is wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop
+	 * event will be sent when the user lifts the finger off the
+	 * device.
+	 *
+	 * This event is optional. If the source is unknown for an
+	 * interaction, no event is sent.
+	 * @param source the event source
+	 */
+	void (*source)(void *data,
+		       struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+		       uint32_t source);
+	/**
+	 * angle changed
+	 *
+	 * Sent whenever the angle on a ring changes.
+	 *
+	 * The angle is provided in degrees clockwise from the logical
+	 * north of the ring in the pad's current rotation.
+	 * @param degrees the current angle in degrees
+	 */
+	void (*angle)(void *data,
+		      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+		      wl_fixed_t degrees);
+	/**
+	 * interaction stopped
+	 *
+	 * Stop notification for ring events.
+	 *
+	 * For some wp_tablet_pad_ring.source types, a
+	 * wp_tablet_pad_ring.stop event is sent to notify a client that
+	 * the interaction with the ring has terminated. This enables the
+	 * client to implement kinetic scrolling. See the
+	 * wp_tablet_pad_ring.source documentation for information on when
+	 * this event may be generated.
+	 *
+	 * Any wp_tablet_pad_ring.angle events with the same source after
+	 * this event should be considered as the start of a new
+	 * interaction.
+	 */
+	void (*stop)(void *data,
+		     struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2);
+	/**
+	 * end of a ring event sequence
+	 *
+	 * Indicates the end of a set of ring events that logically
+	 * belong together. A client is expected to accumulate the data in
+	 * all events within the frame before proceeding.
+	 *
+	 * All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame
+	 * event belong logically together. For example, on termination of
+	 * a finger interaction on a ring the compositor will send a
+	 * wp_tablet_pad_ring.source event, a wp_tablet_pad_ring.stop event
+	 * and a wp_tablet_pad_ring.frame event.
+	 *
+	 * A wp_tablet_pad_ring.frame event is sent for every logical event
+	 * group, even if the group only contains a single
+	 * wp_tablet_pad_ring event. Specifically, a client may get a
+	 * sequence: angle, frame, angle, frame, etc.
+	 * @param time timestamp with millisecond granularity
+	 */
+	void (*frame)(void *data,
+		      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+		      uint32_t time);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+static inline int
+zwp_tablet_pad_ring_v2_add_listener(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+				    const struct zwp_tablet_pad_ring_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_ring_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK 0
+#define ZWP_TABLET_PAD_RING_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_ANGLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_STOP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_FRAME_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_ring_v2 */
+static inline void
+zwp_tablet_pad_ring_v2_set_user_data(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_ring_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_ring_v2 */
+static inline void *
+zwp_tablet_pad_ring_v2_get_user_data(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_ring_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_ring_v2_get_version(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_ring_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ *
+ * Request that the compositor use the provided feedback string
+ * associated with this ring. This request should be issued immediately
+ * after a wp_tablet_pad_group.mode_switch event from the corresponding
+ * group is received, or whenever the ring is mapped to a different
+ * action. See wp_tablet_pad_group.mode_switch for more details.
+ *
+ * Clients are encouraged to provide context-aware descriptions for
+ * the actions associated with the ring; compositors may use this
+ * information to offer visual feedback about the button layout
+ * (eg. on-screen displays).
+ *
+ * The provided string 'description' is a UTF-8 encoded string to be
+ * associated with this ring, and is considered user-visible; general
+ * internationalization rules apply.
+ *
+ * The serial argument will be that of the last
+ * wp_tablet_pad_group.mode_switch event received for the group of this
+ * ring. Requests providing other serials than the most recent one will be
+ * ignored.
+ */
+static inline void
+zwp_tablet_pad_ring_v2_set_feedback(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2, const char *description, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_ring_v2,
+			 ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK, description, serial);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ *
+ * This destroys the client's resource for this ring object.
+ */
+static inline void
+zwp_tablet_pad_ring_v2_destroy(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_ring_v2,
+			 ZWP_TABLET_PAD_RING_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_ring_v2);
+}
+
+#ifndef ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM
+#define ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ * strip axis source
+ *
+ * Describes the source types for strip events. This indicates to the
+ * client how a strip event was physically generated; a client may
+ * adjust the user interface accordingly. For example, events
+ * from a "finger" source may trigger kinetic scrolling.
+ */
+enum zwp_tablet_pad_strip_v2_source {
+	/**
+	 * finger
+	 */
+	ZWP_TABLET_PAD_STRIP_V2_SOURCE_FINGER = 1,
+};
+#endif /* ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ * @struct zwp_tablet_pad_strip_v2_listener
+ */
+struct zwp_tablet_pad_strip_v2_listener {
+	/**
+	 * strip event source
+	 *
+	 * Source information for strip events.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wp_tablet_pad_strip.frame event and carries the source
+	 * information for all events within that frame.
+	 *
+	 * The source specifies how this event was generated. If the source
+	 * is wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop
+	 * event will be sent when the user lifts their finger off the
+	 * device.
+	 *
+	 * This event is optional. If the source is unknown for an
+	 * interaction, no event is sent.
+	 * @param source the event source
+	 */
+	void (*source)(void *data,
+		       struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+		       uint32_t source);
+	/**
+	 * position changed
+	 *
+	 * Sent whenever the position on a strip changes.
+	 *
+	 * The position is normalized to a range of [0, 65535], the 0-value
+	 * represents the top-most and/or left-most position of the strip
+	 * in the pad's current rotation.
+	 * @param position the current position
+	 */
+	void (*position)(void *data,
+			 struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+			 uint32_t position);
+	/**
+	 * interaction stopped
+	 *
+	 * Stop notification for strip events.
+	 *
+	 * For some wp_tablet_pad_strip.source types, a
+	 * wp_tablet_pad_strip.stop event is sent to notify a client that
+	 * the interaction with the strip has terminated. This enables the
+	 * client to implement kinetic scrolling. See the
+	 * wp_tablet_pad_strip.source documentation for information on when
+	 * this event may be generated.
+	 *
+	 * Any wp_tablet_pad_strip.position events with the same source
+	 * after this event should be considered as the start of a new
+	 * interaction.
+	 */
+	void (*stop)(void *data,
+		     struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2);
+	/**
+	 * end of a strip event sequence
+	 *
+	 * Indicates the end of a set of events that represent one
+	 * logical hardware strip event. A client is expected to accumulate
+	 * the data in all events within the frame before proceeding.
+	 *
+	 * All wp_tablet_pad_strip events before a
+	 * wp_tablet_pad_strip.frame event belong logically together. For
+	 * example, on termination of a finger interaction on a strip the
+	 * compositor will send a wp_tablet_pad_strip.source event, a
+	 * wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
+	 * event.
+	 *
+	 * A wp_tablet_pad_strip.frame event is sent for every logical
+	 * event group, even if the group only contains a single
+	 * wp_tablet_pad_strip event. Specifically, a client may get a
+	 * sequence: position, frame, position, frame, etc.
+	 * @param time timestamp with millisecond granularity
+	 */
+	void (*frame)(void *data,
+		      struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+		      uint32_t time);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+static inline int
+zwp_tablet_pad_strip_v2_add_listener(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+				     const struct zwp_tablet_pad_strip_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_strip_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK 0
+#define ZWP_TABLET_PAD_STRIP_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_POSITION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_STOP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_FRAME_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_strip_v2 */
+static inline void
+zwp_tablet_pad_strip_v2_set_user_data(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_strip_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_strip_v2 */
+static inline void *
+zwp_tablet_pad_strip_v2_get_user_data(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_strip_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_strip_v2_get_version(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_strip_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ *
+ * Requests the compositor to use the provided feedback string
+ * associated with this strip. This request should be issued immediately
+ * after a wp_tablet_pad_group.mode_switch event from the corresponding
+ * group is received, or whenever the strip is mapped to a different
+ * action. See wp_tablet_pad_group.mode_switch for more details.
+ *
+ * Clients are encouraged to provide context-aware descriptions for
+ * the actions associated with the strip, and compositors may use this
+ * information to offer visual feedback about the button layout
+ * (eg. on-screen displays).
+ *
+ * The provided string 'description' is a UTF-8 encoded string to be
+ * associated with this ring, and is considered user-visible; general
+ * internationalization rules apply.
+ *
+ * The serial argument will be that of the last
+ * wp_tablet_pad_group.mode_switch event received for the group of this
+ * strip. Requests providing other serials than the most recent one will be
+ * ignored.
+ */
+static inline void
+zwp_tablet_pad_strip_v2_set_feedback(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2, const char *description, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_strip_v2,
+			 ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK, description, serial);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ *
+ * This destroys the client's resource for this strip object.
+ */
+static inline void
+zwp_tablet_pad_strip_v2_destroy(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_strip_v2,
+			 ZWP_TABLET_PAD_STRIP_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_strip_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ * @struct zwp_tablet_pad_group_v2_listener
+ */
+struct zwp_tablet_pad_group_v2_listener {
+	/**
+	 * buttons announced
+	 *
+	 * Sent on wp_tablet_pad_group initialization to announce the
+	 * available buttons in the group. Button indices start at 0, a
+	 * button may only be in one group at a time.
+	 *
+	 * This event is first sent in the initial burst of events before
+	 * the wp_tablet_pad_group.done event.
+	 *
+	 * Some buttons are reserved by the compositor. These buttons may
+	 * not be assigned to any wp_tablet_pad_group. Compositors may
+	 * broadcast this event in the case of changes to the mapping of
+	 * these reserved buttons. If the compositor happens to reserve all
+	 * buttons in a group, this event will be sent with an empty array.
+	 * @param buttons buttons in this group
+	 */
+	void (*buttons)(void *data,
+			struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+			struct wl_array *buttons);
+	/**
+	 * ring announced
+	 *
+	 * Sent on wp_tablet_pad_group initialization to announce
+	 * available rings. One event is sent for each ring available on
+	 * this pad group.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad_group.done event.
+	 */
+	void (*ring)(void *data,
+		     struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+		     struct zwp_tablet_pad_ring_v2 *ring);
+	/**
+	 * strip announced
+	 *
+	 * Sent on wp_tablet_pad initialization to announce available
+	 * strips. One event is sent for each strip available on this pad
+	 * group.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad_group.done event.
+	 */
+	void (*strip)(void *data,
+		      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+		      struct zwp_tablet_pad_strip_v2 *strip);
+	/**
+	 * mode-switch ability announced
+	 *
+	 * Sent on wp_tablet_pad_group initialization to announce that
+	 * the pad group may switch between modes. A client may use a mode
+	 * to store a specific configuration for buttons, rings and strips
+	 * and use the wl_tablet_pad_group.mode_switch event to toggle
+	 * between these configurations. Mode indices start at 0.
+	 *
+	 * Switching modes is compositor-dependent. See the
+	 * wp_tablet_pad_group.mode_switch event for more details.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad_group.done event. This event is only sent when
+	 * more than more than one mode is available.
+	 * @param modes the number of modes
+	 */
+	void (*modes)(void *data,
+		      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+		      uint32_t modes);
+	/**
+	 * tablet group description events sequence complete
+	 *
+	 * This event is sent immediately to signal the end of the
+	 * initial burst of descriptive events. A client may consider the
+	 * static description of the tablet to be complete and finalize
+	 * initialization of the tablet group.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2);
+	/**
+	 * mode switch event
+	 *
+	 * Notification that the mode was switched.
+	 *
+	 * A mode applies to all buttons, rings and strips in a group
+	 * simultaneously, but a client is not required to assign different
+	 * actions for each mode. For example, a client may have
+	 * mode-specific button mappings but map the ring to vertical
+	 * scrolling in all modes. Mode indices start at 0.
+	 *
+	 * Switching modes is compositor-dependent. The compositor may
+	 * provide visual cues to the client about the mode, e.g. by
+	 * toggling LEDs on the tablet device. Mode-switching may be
+	 * software-controlled or controlled by one or more physical
+	 * buttons. For example, on a Wacom Intuos Pro, the button inside
+	 * the ring may be assigned to switch between modes.
+	 *
+	 * The compositor will also send this event after
+	 * wp_tablet_pad.enter on each group in order to notify of the
+	 * current mode. Groups that only feature one mode will use mode=0
+	 * when emitting this event.
+	 *
+	 * If a button action in the new mode differs from the action in
+	 * the previous mode, the client should immediately issue a
+	 * wp_tablet_pad.set_feedback request for each changed button.
+	 *
+	 * If a ring or strip action in the new mode differs from the
+	 * action in the previous mode, the client should immediately issue
+	 * a wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback
+	 * request for each changed ring or strip.
+	 * @param time the time of the event with millisecond granularity
+	 * @param mode the new mode of the pad
+	 */
+	void (*mode_switch)(void *data,
+			    struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+			    uint32_t time,
+			    uint32_t serial,
+			    uint32_t mode);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+static inline int
+zwp_tablet_pad_group_v2_add_listener(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+				     const struct zwp_tablet_pad_group_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_group_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_GROUP_V2_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_BUTTONS_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_RING_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_STRIP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_MODES_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_MODE_SWITCH_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_group_v2 */
+static inline void
+zwp_tablet_pad_group_v2_set_user_data(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_group_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_group_v2 */
+static inline void *
+zwp_tablet_pad_group_v2_get_user_data(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_group_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_group_v2_get_version(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_group_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ *
+ * Destroy the wp_tablet_pad_group object. Objects created from this object
+ * are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_pad_group_v2_destroy(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_group_v2,
+			 ZWP_TABLET_PAD_GROUP_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_group_v2);
+}
+
+#ifndef ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM
+#define ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ * physical button state
+ *
+ * Describes the physical state of a button that caused the button
+ * event.
+ */
+enum zwp_tablet_pad_v2_button_state {
+	/**
+	 * the button is not pressed
+	 */
+	ZWP_TABLET_PAD_V2_BUTTON_STATE_RELEASED = 0,
+	/**
+	 * the button is pressed
+	 */
+	ZWP_TABLET_PAD_V2_BUTTON_STATE_PRESSED = 1,
+};
+#endif /* ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ * @struct zwp_tablet_pad_v2_listener
+ */
+struct zwp_tablet_pad_v2_listener {
+	/**
+	 * group announced
+	 *
+	 * Sent on wp_tablet_pad initialization to announce available
+	 * groups. One event is sent for each pad group available.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad.done event. At least one group will be announced.
+	 */
+	void (*group)(void *data,
+		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		      struct zwp_tablet_pad_group_v2 *pad_group);
+	/**
+	 * path to the device
+	 *
+	 * A system-specific device path that indicates which device is
+	 * behind this wp_tablet_pad. This information may be used to
+	 * gather additional information about the device, e.g. through
+	 * libwacom.
+	 *
+	 * The format of the path is unspecified, it may be a device node,
+	 * a sysfs path, or some other identifier. It is up to the client
+	 * to identify the string provided.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad.done event.
+	 * @param path path to local device
+	 */
+	void (*path)(void *data,
+		     struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		     const char *path);
+	/**
+	 * buttons announced
+	 *
+	 * Sent on wp_tablet_pad initialization to announce the available
+	 * buttons.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad.done event. This event is only sent when at least
+	 * one button is available.
+	 * @param buttons the number of buttons
+	 */
+	void (*buttons)(void *data,
+			struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+			uint32_t buttons);
+	/**
+	 * pad description event sequence complete
+	 *
+	 * This event signals the end of the initial burst of descriptive
+	 * events. A client may consider the static description of the pad
+	 * to be complete and finalize initialization of the pad.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2);
+	/**
+	 * physical button state
+	 *
+	 * Sent whenever the physical state of a button changes.
+	 * @param time the time of the event with millisecond granularity
+	 * @param button the index of the button that changed state
+	 */
+	void (*button)(void *data,
+		       struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		       uint32_t time,
+		       uint32_t button,
+		       uint32_t state);
+	/**
+	 * enter event
+	 *
+	 * Notification that this pad is focused on the specified
+	 * surface.
+	 * @param serial serial number of the enter event
+	 * @param tablet the tablet the pad is attached to
+	 * @param surface surface the pad is focused on
+	 */
+	void (*enter)(void *data,
+		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		      uint32_t serial,
+		      struct zwp_tablet_v2 *tablet,
+		      struct wl_surface *surface);
+	/**
+	 * enter event
+	 *
+	 * Notification that this pad is no longer focused on the
+	 * specified surface.
+	 * @param serial serial number of the leave event
+	 * @param surface surface the pad is no longer focused on
+	 */
+	void (*leave)(void *data,
+		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		      uint32_t serial,
+		      struct wl_surface *surface);
+	/**
+	 * pad removed event
+	 *
+	 * Sent when the pad has been removed from the system. When a
+	 * tablet is removed its pad(s) will be removed too.
+	 *
+	 * When this event is received, the client must destroy all rings,
+	 * strips and groups that were offered by this pad, and issue
+	 * wp_tablet_pad.destroy the pad itself.
+	 */
+	void (*removed)(void *data,
+			struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+static inline int
+zwp_tablet_pad_v2_add_listener(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+			       const struct zwp_tablet_pad_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_V2_SET_FEEDBACK 0
+#define ZWP_TABLET_PAD_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_GROUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_PATH_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_BUTTONS_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_BUTTON_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_LEAVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_REMOVED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_SET_FEEDBACK_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_v2 */
+static inline void
+zwp_tablet_pad_v2_set_user_data(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_v2 */
+static inline void *
+zwp_tablet_pad_v2_get_user_data(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_v2_get_version(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ *
+ * Requests the compositor to use the provided feedback string
+ * associated with this button. This request should be issued immediately
+ * after a wp_tablet_pad_group.mode_switch event from the corresponding
+ * group is received, or whenever a button is mapped to a different
+ * action. See wp_tablet_pad_group.mode_switch for more details.
+ *
+ * Clients are encouraged to provide context-aware descriptions for
+ * the actions associated with each button, and compositors may use
+ * this information to offer visual feedback on the button layout
+ * (e.g. on-screen displays).
+ *
+ * Button indices start at 0. Setting the feedback string on a button
+ * that is reserved by the compositor (i.e. not belonging to any
+ * wp_tablet_pad_group) does not generate an error but the compositor
+ * is free to ignore the request.
+ *
+ * The provided string 'description' is a UTF-8 encoded string to be
+ * associated with this ring, and is considered user-visible; general
+ * internationalization rules apply.
+ *
+ * The serial argument will be that of the last
+ * wp_tablet_pad_group.mode_switch event received for the group of this
+ * button. Requests providing other serials than the most recent one will
+ * be ignored.
+ */
+static inline void
+zwp_tablet_pad_v2_set_feedback(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2, uint32_t button, const char *description, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_v2,
+			 ZWP_TABLET_PAD_V2_SET_FEEDBACK, button, description, serial);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ *
+ * Destroy the wp_tablet_pad object. Objects created from this object
+ * are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_pad_v2_destroy(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_v2,
+			 ZWP_TABLET_PAD_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_v2);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gdk/wayland/tablet-unstable-v2-protocol.c b/gdk/wayland/tablet-unstable-v2-protocol.c
new file mode 100755
index 0000000..9cbbe19
--- /dev/null
+++ b/gdk/wayland/tablet-unstable-v2-protocol.c
@@ -0,0 +1,223 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+/*
+ * Copyright 2014 © Stephen "Lyude" Chandler Paul
+ * Copyright 2015-2016 © Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zwp_tablet_pad_group_v2_interface;
+extern const struct wl_interface zwp_tablet_pad_ring_v2_interface;
+extern const struct wl_interface zwp_tablet_pad_strip_v2_interface;
+extern const struct wl_interface zwp_tablet_pad_v2_interface;
+extern const struct wl_interface zwp_tablet_seat_v2_interface;
+extern const struct wl_interface zwp_tablet_tool_v2_interface;
+extern const struct wl_interface zwp_tablet_v2_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	&zwp_tablet_seat_v2_interface,
+	&wl_seat_interface,
+	&zwp_tablet_v2_interface,
+	&zwp_tablet_tool_v2_interface,
+	&zwp_tablet_pad_v2_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&zwp_tablet_v2_interface,
+	&wl_surface_interface,
+	&zwp_tablet_pad_ring_v2_interface,
+	&zwp_tablet_pad_strip_v2_interface,
+	&zwp_tablet_pad_group_v2_interface,
+	NULL,
+	&zwp_tablet_v2_interface,
+	&wl_surface_interface,
+	NULL,
+	&wl_surface_interface,
+};
+
+static const struct wl_message zwp_tablet_manager_v2_requests[] = {
+	{ "get_tablet_seat", "no", types + 3 },
+	{ "destroy", "", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_manager_v2_interface = {
+	"zwp_tablet_manager_v2", 1,
+	2, zwp_tablet_manager_v2_requests,
+	0, NULL,
+};
+
+static const struct wl_message zwp_tablet_seat_v2_requests[] = {
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_seat_v2_events[] = {
+	{ "tablet_added", "n", types + 5 },
+	{ "tool_added", "n", types + 6 },
+	{ "pad_added", "n", types + 7 },
+};
+
+const struct wl_interface zwp_tablet_seat_v2_interface = {
+	"zwp_tablet_seat_v2", 1,
+	1, zwp_tablet_seat_v2_requests,
+	3, zwp_tablet_seat_v2_events,
+};
+
+static const struct wl_message zwp_tablet_tool_v2_requests[] = {
+	{ "set_cursor", "u?oii", types + 8 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_tool_v2_events[] = {
+	{ "type", "u", types + 0 },
+	{ "hardware_serial", "uu", types + 0 },
+	{ "hardware_id_wacom", "uu", types + 0 },
+	{ "capability", "u", types + 0 },
+	{ "done", "", types + 0 },
+	{ "removed", "", types + 0 },
+	{ "proximity_in", "uoo", types + 12 },
+	{ "proximity_out", "", types + 0 },
+	{ "down", "u", types + 0 },
+	{ "up", "", types + 0 },
+	{ "motion", "ff", types + 0 },
+	{ "pressure", "u", types + 0 },
+	{ "distance", "u", types + 0 },
+	{ "tilt", "ff", types + 0 },
+	{ "rotation", "f", types + 0 },
+	{ "slider", "i", types + 0 },
+	{ "wheel", "fi", types + 0 },
+	{ "button", "uuu", types + 0 },
+	{ "frame", "u", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_tool_v2_interface = {
+	"zwp_tablet_tool_v2", 1,
+	2, zwp_tablet_tool_v2_requests,
+	19, zwp_tablet_tool_v2_events,
+};
+
+static const struct wl_message zwp_tablet_v2_requests[] = {
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_v2_events[] = {
+	{ "name", "s", types + 0 },
+	{ "id", "uu", types + 0 },
+	{ "path", "s", types + 0 },
+	{ "done", "", types + 0 },
+	{ "removed", "", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_v2_interface = {
+	"zwp_tablet_v2", 1,
+	1, zwp_tablet_v2_requests,
+	5, zwp_tablet_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_ring_v2_requests[] = {
+	{ "set_feedback", "su", types + 0 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_ring_v2_events[] = {
+	{ "source", "u", types + 0 },
+	{ "angle", "f", types + 0 },
+	{ "stop", "", types + 0 },
+	{ "frame", "u", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_pad_ring_v2_interface = {
+	"zwp_tablet_pad_ring_v2", 1,
+	2, zwp_tablet_pad_ring_v2_requests,
+	4, zwp_tablet_pad_ring_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_strip_v2_requests[] = {
+	{ "set_feedback", "su", types + 0 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_strip_v2_events[] = {
+	{ "source", "u", types + 0 },
+	{ "position", "u", types + 0 },
+	{ "stop", "", types + 0 },
+	{ "frame", "u", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_pad_strip_v2_interface = {
+	"zwp_tablet_pad_strip_v2", 1,
+	2, zwp_tablet_pad_strip_v2_requests,
+	4, zwp_tablet_pad_strip_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_group_v2_requests[] = {
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_group_v2_events[] = {
+	{ "buttons", "a", types + 0 },
+	{ "ring", "n", types + 15 },
+	{ "strip", "n", types + 16 },
+	{ "modes", "u", types + 0 },
+	{ "done", "", types + 0 },
+	{ "mode_switch", "uuu", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_pad_group_v2_interface = {
+	"zwp_tablet_pad_group_v2", 1,
+	1, zwp_tablet_pad_group_v2_requests,
+	6, zwp_tablet_pad_group_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_v2_requests[] = {
+	{ "set_feedback", "usu", types + 0 },
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_v2_events[] = {
+	{ "group", "n", types + 17 },
+	{ "path", "s", types + 0 },
+	{ "buttons", "u", types + 0 },
+	{ "done", "", types + 0 },
+	{ "button", "uuu", types + 0 },
+	{ "enter", "uoo", types + 18 },
+	{ "leave", "uo", types + 21 },
+	{ "removed", "", types + 0 },
+};
+
+const struct wl_interface zwp_tablet_pad_v2_interface = {
+	"zwp_tablet_pad_v2", 1,
+	2, zwp_tablet_pad_v2_requests,
+	8, zwp_tablet_pad_v2_events,
+};
+
diff --git a/gdk/wayland/xdg-foreign-unstable-v1-client-protocol.h b/gdk/wayland/xdg-foreign-unstable-v1-client-protocol.h
new file mode 100755
index 0000000..ffb922b
--- /dev/null
+++ b/gdk/wayland/xdg-foreign-unstable-v1-client-protocol.h
@@ -0,0 +1,477 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef XDG_FOREIGN_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define XDG_FOREIGN_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_foreign_unstable_v1 The xdg_foreign_unstable_v1 protocol
+ * Protocol for exporting xdg surface handles
+ *
+ * @section page_desc_xdg_foreign_unstable_v1 Description
+ *
+ * This protocol specifies a way for making it possible to reference a surface
+ * of a different client. With such a reference, a client can, by using the
+ * interfaces provided by this protocol, manipulate the relationship between
+ * its own surfaces and the surface of some other client. For example, stack
+ * some of its own surface above the other clients surface.
+ *
+ * In order for a client A to get a reference of a surface of client B, client
+ * B must first export its surface using xdg_exporter.export. Upon doing this,
+ * client B will receive a handle (a unique string) that it may share with
+ * client A in some way (for example D-Bus). After client A has received the
+ * handle from client B, it may use xdg_importer.import to create a reference
+ * to the surface client B just exported. See the corresponding requests for
+ * details.
+ *
+ * A possible use case for this is out-of-process dialogs. For example when a
+ * sandboxed client without file system access needs the user to select a file
+ * on the file system, given sandbox environment support, it can export its
+ * surface, passing the exported surface handle to an unsandboxed process that
+ * can show a file browser dialog and stack it above the sandboxed client's
+ * surface.
+ *
+ * Warning! The protocol described in this file is experimental and backward
+ * incompatible changes may be made. Backward compatible changes may be added
+ * together with the corresponding interface version bump. Backward
+ * incompatible changes are done by bumping the version number in the protocol
+ * and interface names and resetting the interface version. Once the protocol
+ * is to be declared stable, the 'z' prefix and the version number in the
+ * protocol and interface names are removed and the interface version number is
+ * reset.
+ *
+ * @section page_ifaces_xdg_foreign_unstable_v1 Interfaces
+ * - @subpage page_iface_zxdg_exporter_v1 - interface for exporting surfaces
+ * - @subpage page_iface_zxdg_importer_v1 - interface for importing surfaces
+ * - @subpage page_iface_zxdg_exported_v1 - an exported surface handle
+ * - @subpage page_iface_zxdg_imported_v1 - an imported surface handle
+ * @section page_copyright_xdg_foreign_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright © 2015-2016 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_surface;
+struct zxdg_exported_v1;
+struct zxdg_exporter_v1;
+struct zxdg_imported_v1;
+struct zxdg_importer_v1;
+
+/**
+ * @page page_iface_zxdg_exporter_v1 zxdg_exporter_v1
+ * @section page_iface_zxdg_exporter_v1_desc Description
+ *
+ * A global interface used for exporting surfaces that can later be imported
+ * using xdg_importer.
+ * @section page_iface_zxdg_exporter_v1_api API
+ * See @ref iface_zxdg_exporter_v1.
+ */
+/**
+ * @defgroup iface_zxdg_exporter_v1 The zxdg_exporter_v1 interface
+ *
+ * A global interface used for exporting surfaces that can later be imported
+ * using xdg_importer.
+ */
+extern const struct wl_interface zxdg_exporter_v1_interface;
+/**
+ * @page page_iface_zxdg_importer_v1 zxdg_importer_v1
+ * @section page_iface_zxdg_importer_v1_desc Description
+ *
+ * A global interface used for importing surfaces exported by xdg_exporter.
+ * With this interface, a client can create a reference to a surface of
+ * another client.
+ * @section page_iface_zxdg_importer_v1_api API
+ * See @ref iface_zxdg_importer_v1.
+ */
+/**
+ * @defgroup iface_zxdg_importer_v1 The zxdg_importer_v1 interface
+ *
+ * A global interface used for importing surfaces exported by xdg_exporter.
+ * With this interface, a client can create a reference to a surface of
+ * another client.
+ */
+extern const struct wl_interface zxdg_importer_v1_interface;
+/**
+ * @page page_iface_zxdg_exported_v1 zxdg_exported_v1
+ * @section page_iface_zxdg_exported_v1_desc Description
+ *
+ * A xdg_exported object represents an exported reference to a surface. The
+ * exported surface may be referenced as long as the xdg_exported object not
+ * destroyed. Destroying the xdg_exported invalidates any relationship the
+ * importer may have established using xdg_imported.
+ * @section page_iface_zxdg_exported_v1_api API
+ * See @ref iface_zxdg_exported_v1.
+ */
+/**
+ * @defgroup iface_zxdg_exported_v1 The zxdg_exported_v1 interface
+ *
+ * A xdg_exported object represents an exported reference to a surface. The
+ * exported surface may be referenced as long as the xdg_exported object not
+ * destroyed. Destroying the xdg_exported invalidates any relationship the
+ * importer may have established using xdg_imported.
+ */
+extern const struct wl_interface zxdg_exported_v1_interface;
+/**
+ * @page page_iface_zxdg_imported_v1 zxdg_imported_v1
+ * @section page_iface_zxdg_imported_v1_desc Description
+ *
+ * A xdg_imported object represents an imported reference to surface exported
+ * by some client. A client can use this interface to manipulate
+ * relationships between its own surfaces and the imported surface.
+ * @section page_iface_zxdg_imported_v1_api API
+ * See @ref iface_zxdg_imported_v1.
+ */
+/**
+ * @defgroup iface_zxdg_imported_v1 The zxdg_imported_v1 interface
+ *
+ * A xdg_imported object represents an imported reference to surface exported
+ * by some client. A client can use this interface to manipulate
+ * relationships between its own surfaces and the imported surface.
+ */
+extern const struct wl_interface zxdg_imported_v1_interface;
+
+#define ZXDG_EXPORTER_V1_DESTROY 0
+#define ZXDG_EXPORTER_V1_EXPORT 1
+
+
+/**
+ * @ingroup iface_zxdg_exporter_v1
+ */
+#define ZXDG_EXPORTER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_exporter_v1
+ */
+#define ZXDG_EXPORTER_V1_EXPORT_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_exporter_v1 */
+static inline void
+zxdg_exporter_v1_set_user_data(struct zxdg_exporter_v1 *zxdg_exporter_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_exporter_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_exporter_v1 */
+static inline void *
+zxdg_exporter_v1_get_user_data(struct zxdg_exporter_v1 *zxdg_exporter_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_exporter_v1);
+}
+
+static inline uint32_t
+zxdg_exporter_v1_get_version(struct zxdg_exporter_v1 *zxdg_exporter_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_exporter_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_exporter_v1
+ *
+ * Notify the compositor that the xdg_exporter object will no longer be
+ * used.
+ */
+static inline void
+zxdg_exporter_v1_destroy(struct zxdg_exporter_v1 *zxdg_exporter_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_exporter_v1,
+			 ZXDG_EXPORTER_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_exporter_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_exporter_v1
+ *
+ * The export request exports the passed surface so that it can later be
+ * imported via xdg_importer. When called, a new xdg_exported object will
+ * be created and xdg_exported.handle will be sent immediately. See the
+ * corresponding interface and event for details.
+ *
+ * A surface may be exported multiple times, and each exported handle may
+ * be used to create a xdg_imported multiple times. Only xdg_surface
+ * surfaces may be exported.
+ */
+static inline struct zxdg_exported_v1 *
+zxdg_exporter_v1_export(struct zxdg_exporter_v1 *zxdg_exporter_v1, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_exporter_v1,
+			 ZXDG_EXPORTER_V1_EXPORT, &zxdg_exported_v1_interface, NULL, surface);
+
+	return (struct zxdg_exported_v1 *) id;
+}
+
+#define ZXDG_IMPORTER_V1_DESTROY 0
+#define ZXDG_IMPORTER_V1_IMPORT 1
+
+
+/**
+ * @ingroup iface_zxdg_importer_v1
+ */
+#define ZXDG_IMPORTER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_importer_v1
+ */
+#define ZXDG_IMPORTER_V1_IMPORT_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_importer_v1 */
+static inline void
+zxdg_importer_v1_set_user_data(struct zxdg_importer_v1 *zxdg_importer_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_importer_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_importer_v1 */
+static inline void *
+zxdg_importer_v1_get_user_data(struct zxdg_importer_v1 *zxdg_importer_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_importer_v1);
+}
+
+static inline uint32_t
+zxdg_importer_v1_get_version(struct zxdg_importer_v1 *zxdg_importer_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_importer_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_importer_v1
+ *
+ * Notify the compositor that the xdg_importer object will no longer be
+ * used.
+ */
+static inline void
+zxdg_importer_v1_destroy(struct zxdg_importer_v1 *zxdg_importer_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_importer_v1,
+			 ZXDG_IMPORTER_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_importer_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_importer_v1
+ *
+ * The import request imports a surface from any client given a handle
+ * retrieved by exporting said surface using xdg_exporter.export. When
+ * called, a new xdg_imported object will be created. This new object
+ * represents the imported surface, and the importing client can
+ * manipulate its relationship using it. See xdg_imported for details.
+ */
+static inline struct zxdg_imported_v1 *
+zxdg_importer_v1_import(struct zxdg_importer_v1 *zxdg_importer_v1, const char *handle)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_importer_v1,
+			 ZXDG_IMPORTER_V1_IMPORT, &zxdg_imported_v1_interface, NULL, handle);
+
+	return (struct zxdg_imported_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_exported_v1
+ * @struct zxdg_exported_v1_listener
+ */
+struct zxdg_exported_v1_listener {
+	/**
+	 * the exported surface handle
+	 *
+	 * The handle event contains the unique handle of this exported
+	 * surface reference. It may be shared with any client, which then
+	 * can use it to import the surface by calling xdg_importer.import.
+	 * A handle may be used to import the surface multiple times.
+	 * @param handle the exported surface handle
+	 */
+	void (*handle)(void *data,
+		       struct zxdg_exported_v1 *zxdg_exported_v1,
+		       const char *handle);
+};
+
+/**
+ * @ingroup iface_zxdg_exported_v1
+ */
+static inline int
+zxdg_exported_v1_add_listener(struct zxdg_exported_v1 *zxdg_exported_v1,
+			      const struct zxdg_exported_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_exported_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_EXPORTED_V1_DESTROY 0
+
+/**
+ * @ingroup iface_zxdg_exported_v1
+ */
+#define ZXDG_EXPORTED_V1_HANDLE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_exported_v1
+ */
+#define ZXDG_EXPORTED_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_exported_v1 */
+static inline void
+zxdg_exported_v1_set_user_data(struct zxdg_exported_v1 *zxdg_exported_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_exported_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_exported_v1 */
+static inline void *
+zxdg_exported_v1_get_user_data(struct zxdg_exported_v1 *zxdg_exported_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_exported_v1);
+}
+
+static inline uint32_t
+zxdg_exported_v1_get_version(struct zxdg_exported_v1 *zxdg_exported_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_exported_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_exported_v1
+ *
+ * Revoke the previously exported surface. This invalidates any
+ * relationship the importer may have set up using the xdg_imported created
+ * given the handle sent via xdg_exported.handle.
+ */
+static inline void
+zxdg_exported_v1_destroy(struct zxdg_exported_v1 *zxdg_exported_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_exported_v1,
+			 ZXDG_EXPORTED_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_exported_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_imported_v1
+ * @struct zxdg_imported_v1_listener
+ */
+struct zxdg_imported_v1_listener {
+	/**
+	 * the imported surface handle has been destroyed
+	 *
+	 * The imported surface handle has been destroyed and any
+	 * relationship set up has been invalidated. This may happen for
+	 * various reasons, for example if the exported surface or the
+	 * exported surface handle has been destroyed, if the handle used
+	 * for importing was invalid.
+	 */
+	void (*destroyed)(void *data,
+			  struct zxdg_imported_v1 *zxdg_imported_v1);
+};
+
+/**
+ * @ingroup iface_zxdg_imported_v1
+ */
+static inline int
+zxdg_imported_v1_add_listener(struct zxdg_imported_v1 *zxdg_imported_v1,
+			      const struct zxdg_imported_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_imported_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_IMPORTED_V1_DESTROY 0
+#define ZXDG_IMPORTED_V1_SET_PARENT_OF 1
+
+/**
+ * @ingroup iface_zxdg_imported_v1
+ */
+#define ZXDG_IMPORTED_V1_DESTROYED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_imported_v1
+ */
+#define ZXDG_IMPORTED_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_imported_v1
+ */
+#define ZXDG_IMPORTED_V1_SET_PARENT_OF_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_imported_v1 */
+static inline void
+zxdg_imported_v1_set_user_data(struct zxdg_imported_v1 *zxdg_imported_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_imported_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_imported_v1 */
+static inline void *
+zxdg_imported_v1_get_user_data(struct zxdg_imported_v1 *zxdg_imported_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_imported_v1);
+}
+
+static inline uint32_t
+zxdg_imported_v1_get_version(struct zxdg_imported_v1 *zxdg_imported_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_imported_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_imported_v1
+ *
+ * Notify the compositor that it will no longer use the xdg_imported
+ * object. Any relationship that may have been set up will at this point
+ * be invalidated.
+ */
+static inline void
+zxdg_imported_v1_destroy(struct zxdg_imported_v1 *zxdg_imported_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_imported_v1,
+			 ZXDG_IMPORTED_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_imported_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_imported_v1
+ *
+ * Set the imported surface as the parent of some surface of the client.
+ * The passed surface must be a toplevel xdg_surface. Calling this function
+ * sets up a surface to surface relation with the same stacking and positioning
+ * semantics as xdg_surface.set_parent.
+ */
+static inline void
+zxdg_imported_v1_set_parent_of(struct zxdg_imported_v1 *zxdg_imported_v1, struct wl_surface *surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_imported_v1,
+			 ZXDG_IMPORTED_V1_SET_PARENT_OF, surface);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gdk/wayland/xdg-foreign-unstable-v1-protocol.c b/gdk/wayland/xdg-foreign-unstable-v1-protocol.c
new file mode 100755
index 0000000..1e675b5
--- /dev/null
+++ b/gdk/wayland/xdg-foreign-unstable-v1-protocol.c
@@ -0,0 +1,93 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+/*
+ * Copyright © 2015-2016 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zxdg_exported_v1_interface;
+extern const struct wl_interface zxdg_imported_v1_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	&zxdg_exported_v1_interface,
+	&wl_surface_interface,
+	&zxdg_imported_v1_interface,
+	NULL,
+	&wl_surface_interface,
+};
+
+static const struct wl_message zxdg_exporter_v1_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "export", "no", types + 1 },
+};
+
+const struct wl_interface zxdg_exporter_v1_interface = {
+	"zxdg_exporter_v1", 1,
+	2, zxdg_exporter_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zxdg_importer_v1_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "import", "ns", types + 3 },
+};
+
+const struct wl_interface zxdg_importer_v1_interface = {
+	"zxdg_importer_v1", 1,
+	2, zxdg_importer_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zxdg_exported_v1_requests[] = {
+	{ "destroy", "", types + 0 },
+};
+
+static const struct wl_message zxdg_exported_v1_events[] = {
+	{ "handle", "s", types + 0 },
+};
+
+const struct wl_interface zxdg_exported_v1_interface = {
+	"zxdg_exported_v1", 1,
+	1, zxdg_exported_v1_requests,
+	1, zxdg_exported_v1_events,
+};
+
+static const struct wl_message zxdg_imported_v1_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "set_parent_of", "o", types + 5 },
+};
+
+static const struct wl_message zxdg_imported_v1_events[] = {
+	{ "destroyed", "", types + 0 },
+};
+
+const struct wl_interface zxdg_imported_v1_interface = {
+	"zxdg_imported_v1", 1,
+	2, zxdg_imported_v1_requests,
+	1, zxdg_imported_v1_events,
+};
+
diff --git a/gdk/wayland/xdg-shell-unstable-v6-client-protocol.h b/gdk/wayland/xdg-shell-unstable-v6-client-protocol.h
new file mode 100755
index 0000000..14cc9ad
--- /dev/null
+++ b/gdk/wayland/xdg-shell-unstable-v6-client-protocol.h
@@ -0,0 +1,1744 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+#ifndef XDG_SHELL_UNSTABLE_V6_CLIENT_PROTOCOL_H
+#define XDG_SHELL_UNSTABLE_V6_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_shell_unstable_v6 The xdg_shell_unstable_v6 protocol
+ * @section page_ifaces_xdg_shell_unstable_v6 Interfaces
+ * - @subpage page_iface_zxdg_shell_v6 - create desktop-style surfaces
+ * - @subpage page_iface_zxdg_positioner_v6 - child surface positioner
+ * - @subpage page_iface_zxdg_surface_v6 - desktop user interface surface base interface
+ * - @subpage page_iface_zxdg_toplevel_v6 - toplevel surface
+ * - @subpage page_iface_zxdg_popup_v6 - short-lived, popup surfaces for menus
+ * @section page_copyright_xdg_shell_unstable_v6 Copyright
+ * <pre>
+ *
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct wl_seat;
+struct wl_surface;
+struct zxdg_popup_v6;
+struct zxdg_positioner_v6;
+struct zxdg_shell_v6;
+struct zxdg_surface_v6;
+struct zxdg_toplevel_v6;
+
+/**
+ * @page page_iface_zxdg_shell_v6 zxdg_shell_v6
+ * @section page_iface_zxdg_shell_v6_desc Description
+ *
+ * xdg_shell allows clients to turn a wl_surface into a "real window"
+ * which can be dragged, resized, stacked, and moved around by the
+ * user. Everything about this interface is suited towards traditional
+ * desktop environments.
+ * @section page_iface_zxdg_shell_v6_api API
+ * See @ref iface_zxdg_shell_v6.
+ */
+/**
+ * @defgroup iface_zxdg_shell_v6 The zxdg_shell_v6 interface
+ *
+ * xdg_shell allows clients to turn a wl_surface into a "real window"
+ * which can be dragged, resized, stacked, and moved around by the
+ * user. Everything about this interface is suited towards traditional
+ * desktop environments.
+ */
+extern const struct wl_interface zxdg_shell_v6_interface;
+/**
+ * @page page_iface_zxdg_positioner_v6 zxdg_positioner_v6
+ * @section page_iface_zxdg_positioner_v6_desc Description
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ * @section page_iface_zxdg_positioner_v6_api API
+ * See @ref iface_zxdg_positioner_v6.
+ */
+/**
+ * @defgroup iface_zxdg_positioner_v6 The zxdg_positioner_v6 interface
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ */
+extern const struct wl_interface zxdg_positioner_v6_interface;
+/**
+ * @page page_iface_zxdg_surface_v6 zxdg_surface_v6
+ * @section page_iface_zxdg_surface_v6_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * For a surface to be mapped by the compositor, the following conditions
+ * must be met: (1) the client has assigned a xdg_surface based role to the
+ * surface, (2) the client has set and committed the xdg_surface state and
+ * the role dependent state to the surface and (3) the client has committed a
+ * buffer to the surface.
+ * @section page_iface_zxdg_surface_v6_api API
+ * See @ref iface_zxdg_surface_v6.
+ */
+/**
+ * @defgroup iface_zxdg_surface_v6 The zxdg_surface_v6 interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * For a surface to be mapped by the compositor, the following conditions
+ * must be met: (1) the client has assigned a xdg_surface based role to the
+ * surface, (2) the client has set and committed the xdg_surface state and
+ * the role dependent state to the surface and (3) the client has committed a
+ * buffer to the surface.
+ */
+extern const struct wl_interface zxdg_surface_v6_interface;
+/**
+ * @page page_iface_zxdg_toplevel_v6 zxdg_toplevel_v6
+ * @section page_iface_zxdg_toplevel_v6_desc Description
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ * @section page_iface_zxdg_toplevel_v6_api API
+ * See @ref iface_zxdg_toplevel_v6.
+ */
+/**
+ * @defgroup iface_zxdg_toplevel_v6 The zxdg_toplevel_v6 interface
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ */
+extern const struct wl_interface zxdg_toplevel_v6_interface;
+/**
+ * @page page_iface_zxdg_popup_v6 zxdg_popup_v6
+ * @section page_iface_zxdg_popup_v6_desc Description
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * The parent surface must have either the xdg_toplevel or xdg_popup surface
+ * role.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ * @section page_iface_zxdg_popup_v6_api API
+ * See @ref iface_zxdg_popup_v6.
+ */
+/**
+ * @defgroup iface_zxdg_popup_v6 The zxdg_popup_v6 interface
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * The parent surface must have either the xdg_toplevel or xdg_popup surface
+ * role.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ */
+extern const struct wl_interface zxdg_popup_v6_interface;
+
+#ifndef ZXDG_SHELL_V6_ERROR_ENUM
+#define ZXDG_SHELL_V6_ERROR_ENUM
+enum zxdg_shell_v6_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	ZXDG_SHELL_V6_ERROR_ROLE = 0,
+	/**
+	 * xdg_shell was destroyed before children
+	 */
+	ZXDG_SHELL_V6_ERROR_DEFUNCT_SURFACES = 1,
+	/**
+	 * the client tried to map or destroy a non-topmost popup
+	 */
+	ZXDG_SHELL_V6_ERROR_NOT_THE_TOPMOST_POPUP = 2,
+	/**
+	 * the client specified an invalid popup parent surface
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_POPUP_PARENT = 3,
+	/**
+	 * the client provided an invalid surface state
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_SURFACE_STATE = 4,
+	/**
+	 * the client provided an invalid positioner
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_POSITIONER = 5,
+};
+#endif /* ZXDG_SHELL_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ * @struct zxdg_shell_v6_listener
+ */
+struct zxdg_shell_v6_listener {
+	/**
+	 * check if the client is alive
+	 *
+	 * The ping event asks the client if it's still alive. Pass the
+	 * serial specified in the event back to the compositor by sending
+	 * a "pong" request back with the specified serial. See
+	 * xdg_shell.ping.
+	 *
+	 * Compositors can use this to determine if the client is still
+	 * alive. It's unspecified what will happen if the client doesn't
+	 * respond to the ping request, or in what timeframe. Clients
+	 * should try to respond in a reasonable amount of time.
+	 *
+	 * A compositor is free to ping in any way it wants, but a client
+	 * must always respond to any xdg_shell object it created.
+	 * @param serial pass this to the pong request
+	 */
+	void (*ping)(void *data,
+		     struct zxdg_shell_v6 *zxdg_shell_v6,
+		     uint32_t serial);
+};
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+static inline int
+zxdg_shell_v6_add_listener(struct zxdg_shell_v6 *zxdg_shell_v6,
+			   const struct zxdg_shell_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_shell_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_SHELL_V6_DESTROY 0
+#define ZXDG_SHELL_V6_CREATE_POSITIONER 1
+#define ZXDG_SHELL_V6_GET_XDG_SURFACE 2
+#define ZXDG_SHELL_V6_PONG 3
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_PING_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_CREATE_POSITIONER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_GET_XDG_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_PONG_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_shell_v6 */
+static inline void
+zxdg_shell_v6_set_user_data(struct zxdg_shell_v6 *zxdg_shell_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_shell_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_shell_v6 */
+static inline void *
+zxdg_shell_v6_get_user_data(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_shell_v6);
+}
+
+static inline uint32_t
+zxdg_shell_v6_get_version(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_shell_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * Destroy this xdg_shell object.
+ *
+ * Destroying a bound xdg_shell object while there are surfaces
+ * still alive created by this xdg_shell object instance is illegal
+ * and will result in a protocol error.
+ */
+static inline void
+zxdg_shell_v6_destroy(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_shell_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * Create a positioner object. A positioner object is used to position
+ * surfaces relative to some parent surface. See the interface description
+ * and xdg_surface.get_popup for details.
+ */
+static inline struct zxdg_positioner_v6 *
+zxdg_shell_v6_create_positioner(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_CREATE_POSITIONER, &zxdg_positioner_v6_interface, NULL);
+
+	return (struct zxdg_positioner_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * This creates an xdg_surface for the given surface. While xdg_surface
+ * itself is not a role, the corresponding surface may only be assigned
+ * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
+ *
+ * This creates an xdg_surface for the given surface. An xdg_surface is
+ * used as basis to define a role to a given surface, such as xdg_toplevel
+ * or xdg_popup. It also manages functionality shared between xdg_surface
+ * based surface roles.
+ *
+ * See the documentation of xdg_surface for more details about what an
+ * xdg_surface is and how it is used.
+ */
+static inline struct zxdg_surface_v6 *
+zxdg_shell_v6_get_xdg_surface(struct zxdg_shell_v6 *zxdg_shell_v6, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_GET_XDG_SURFACE, &zxdg_surface_v6_interface, NULL, surface);
+
+	return (struct zxdg_surface_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * A client must respond to a ping event with a pong request or
+ * the client may be deemed unresponsive. See xdg_shell.ping.
+ */
+static inline void
+zxdg_shell_v6_pong(struct zxdg_shell_v6 *zxdg_shell_v6, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_PONG, serial);
+}
+
+#ifndef ZXDG_POSITIONER_V6_ERROR_ENUM
+#define ZXDG_POSITIONER_V6_ERROR_ENUM
+enum zxdg_positioner_v6_error {
+	/**
+	 * invalid input provided
+	 */
+	ZXDG_POSITIONER_V6_ERROR_INVALID_INPUT = 0,
+};
+#endif /* ZXDG_POSITIONER_V6_ERROR_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_ANCHOR_ENUM
+#define ZXDG_POSITIONER_V6_ANCHOR_ENUM
+enum zxdg_positioner_v6_anchor {
+	/**
+	 * the center of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_NONE = 0,
+	/**
+	 * the top edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_TOP = 1,
+	/**
+	 * the bottom edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_BOTTOM = 2,
+	/**
+	 * the left edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_LEFT = 4,
+	/**
+	 * the right edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_RIGHT = 8,
+};
+#endif /* ZXDG_POSITIONER_V6_ANCHOR_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_GRAVITY_ENUM
+#define ZXDG_POSITIONER_V6_GRAVITY_ENUM
+enum zxdg_positioner_v6_gravity {
+	/**
+	 * center over the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_NONE = 0,
+	/**
+	 * position above the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_TOP = 1,
+	/**
+	 * position below the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_BOTTOM = 2,
+	/**
+	 * position to the left of the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_LEFT = 4,
+	/**
+	 * position to the right of the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_RIGHT = 8,
+};
+#endif /* ZXDG_POSITIONER_V6_GRAVITY_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM
+#define ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ * vertically resize the surface
+ *
+ * Resize the surface vertically so that it is completely unconstrained.
+ */
+enum zxdg_positioner_v6_constraint_adjustment {
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_NONE = 0,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
+};
+#endif /* ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM */
+
+#define ZXDG_POSITIONER_V6_DESTROY 0
+#define ZXDG_POSITIONER_V6_SET_SIZE 1
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_RECT 2
+#define ZXDG_POSITIONER_V6_SET_ANCHOR 3
+#define ZXDG_POSITIONER_V6_SET_GRAVITY 4
+#define ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT 5
+#define ZXDG_POSITIONER_V6_SET_OFFSET 6
+
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_RECT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_GRAVITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_OFFSET_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_positioner_v6 */
+static inline void
+zxdg_positioner_v6_set_user_data(struct zxdg_positioner_v6 *zxdg_positioner_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_positioner_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_positioner_v6 */
+static inline void *
+zxdg_positioner_v6_get_user_data(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+static inline uint32_t
+zxdg_positioner_v6_get_version(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Notify the compositor that the xdg_positioner will no longer be used.
+ */
+static inline void
+zxdg_positioner_v6_destroy(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Set the size of the surface that is to be positioned with the positioner
+ * object. The size is in surface-local coordinates and corresponds to the
+ * window geometry. See xdg_surface.set_window_geometry.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_size(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify the anchor rectangle within the parent surface that the child
+ * surface will be placed relative to. The rectangle is relative to the
+ * window geometry as defined by xdg_surface.set_window_geometry of the
+ * parent surface. The rectangle must be at least 1x1 large.
+ *
+ * When the xdg_positioner object is used to position a child surface, the
+ * anchor rectangle may not extend outside the window geometry of the
+ * positioned child's parent surface.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_anchor_rect(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_ANCHOR_RECT, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Defines a set of edges for the anchor rectangle. These are used to
+ * derive an anchor point that the child surface will be positioned
+ * relative to. If two orthogonal edges are specified (e.g. 'top' and
+ * 'left'), then the anchor point will be the intersection of the edges
+ * (e.g. the top left position of the rectangle); otherwise, the derived
+ * anchor point will be centered on the specified edge, or in the center of
+ * the anchor rectangle if no edge is specified.
+ *
+ * If two parallel anchor edges are specified (e.g. 'left' and 'right'),
+ * the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_anchor(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t anchor)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_ANCHOR, anchor);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Defines in what direction a surface should be positioned, relative to
+ * the anchor point of the parent surface. If two orthogonal gravities are
+ * specified (e.g. 'bottom' and 'right'), then the child surface will be
+ * placed in the specified direction; otherwise, the child surface will be
+ * centered over the anchor point on any axis that had no gravity
+ * specified.
+ *
+ * If two parallel gravities are specified (e.g. 'left' and 'right'), the
+ * invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_gravity(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t gravity)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_GRAVITY, gravity);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify how the window should be positioned if the originally intended
+ * position caused the surface to be constrained, meaning at least
+ * partially outside positioning boundaries set by the compositor. The
+ * adjustment is set by constructing a bitmask describing the adjustment to
+ * be made when the surface is constrained on that axis.
+ *
+ * If no bit for one axis is set, the compositor will assume that the child
+ * surface should not change its position on that axis when constrained.
+ *
+ * If more than one bit for one axis is set, the order of how adjustments
+ * are applied is specified in the corresponding adjustment descriptions.
+ *
+ * The default adjustment is none.
+ */
+static inline void
+zxdg_positioner_v6_set_constraint_adjustment(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t constraint_adjustment)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT, constraint_adjustment);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify the surface position offset relative to the position of the
+ * anchor on the anchor rectangle and the anchor on the surface. For
+ * example if the anchor of the anchor rectangle is at (x, y), the surface
+ * has the gravity bottom|right, and the offset is (ox, oy), the calculated
+ * surface position will be (x + ox, y + oy). The offset position of the
+ * surface is the one used for constraint testing. See
+ * set_constraint_adjustment.
+ *
+ * An example use case is placing a popup menu on top of a user interface
+ * element, while aligning the user interface element of the parent surface
+ * with some user interface element placed somewhere in the popup surface.
+ */
+static inline void
+zxdg_positioner_v6_set_offset(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_OFFSET, x, y);
+}
+
+#ifndef ZXDG_SURFACE_V6_ERROR_ENUM
+#define ZXDG_SURFACE_V6_ERROR_ENUM
+enum zxdg_surface_v6_error {
+	ZXDG_SURFACE_V6_ERROR_NOT_CONSTRUCTED = 1,
+	ZXDG_SURFACE_V6_ERROR_ALREADY_CONSTRUCTED = 2,
+	ZXDG_SURFACE_V6_ERROR_UNCONFIGURED_BUFFER = 3,
+};
+#endif /* ZXDG_SURFACE_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ * @struct zxdg_surface_v6_listener
+ */
+struct zxdg_surface_v6_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * The configure event marks the end of a configure sequence. A
+	 * configure sequence is a set of one or more events configuring
+	 * the state of the xdg_surface, including the final
+	 * xdg_surface.configure event.
+	 *
+	 * Where applicable, xdg_surface surface roles will during a
+	 * configure sequence extend this event as a latched state sent as
+	 * events before the xdg_surface.configure event. Such events
+	 * should be considered to make up a set of atomically applied
+	 * configuration states, where the xdg_surface.configure commits
+	 * the accumulated state.
+	 *
+	 * Clients should arrange their surface for the new states, and
+	 * then send an ack_configure request with the serial sent in this
+	 * configure event at some point before committing the new surface.
+	 *
+	 * If the client receives multiple configure events before it can
+	 * respond to one, it is free to discard all but the last event it
+	 * received.
+	 * @param serial serial of the configure event
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_surface_v6 *zxdg_surface_v6,
+			  uint32_t serial);
+};
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+static inline int
+zxdg_surface_v6_add_listener(struct zxdg_surface_v6 *zxdg_surface_v6,
+			     const struct zxdg_surface_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_surface_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_SURFACE_V6_DESTROY 0
+#define ZXDG_SURFACE_V6_GET_TOPLEVEL 1
+#define ZXDG_SURFACE_V6_GET_POPUP 2
+#define ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY 3
+#define ZXDG_SURFACE_V6_ACK_CONFIGURE 4
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_GET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_GET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_ACK_CONFIGURE_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_surface_v6 */
+static inline void
+zxdg_surface_v6_set_user_data(struct zxdg_surface_v6 *zxdg_surface_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_surface_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_surface_v6 */
+static inline void *
+zxdg_surface_v6_get_user_data(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_surface_v6);
+}
+
+static inline uint32_t
+zxdg_surface_v6_get_version(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_surface_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * Destroy the xdg_surface object. An xdg_surface must only be destroyed
+ * after its role object has been destroyed.
+ */
+static inline void
+zxdg_surface_v6_destroy(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_surface_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * This creates an xdg_toplevel object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_toplevel role.
+ *
+ * See the documentation of xdg_toplevel for more details about what an
+ * xdg_toplevel is and how it is used.
+ */
+static inline struct zxdg_toplevel_v6 *
+zxdg_surface_v6_get_toplevel(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_GET_TOPLEVEL, &zxdg_toplevel_v6_interface, NULL);
+
+	return (struct zxdg_toplevel_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * This creates an xdg_popup object for the given xdg_surface and gives the
+ * associated wl_surface the xdg_popup role.
+ *
+ * See the documentation of xdg_popup for more details about what an
+ * xdg_popup is and how it is used.
+ */
+static inline struct zxdg_popup_v6 *
+zxdg_surface_v6_get_popup(struct zxdg_surface_v6 *zxdg_surface_v6, struct zxdg_surface_v6 *parent, struct zxdg_positioner_v6 *positioner)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_GET_POPUP, &zxdg_popup_v6_interface, NULL, parent, positioner);
+
+	return (struct zxdg_popup_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * The window geometry of a surface is its "visible bounds" from the
+ * user's perspective. Client-side decorations often have invisible
+ * portions like drop-shadows which should be ignored for the
+ * purposes of aligning, placing and constraining windows.
+ *
+ * The window geometry is double buffered, and will be applied at the
+ * time wl_surface.commit of the corresponding wl_surface is called.
+ *
+ * Once the window geometry of the surface is set, it is not possible to
+ * unset it, and it will remain the same until set_window_geometry is
+ * called again, even if a new subsurface or buffer is attached.
+ *
+ * If never set, the value is the full bounds of the surface,
+ * including any subsurfaces. This updates dynamically on every
+ * commit. This unset is meant for extremely simple clients.
+ *
+ * The arguments are given in the surface-local coordinate space of
+ * the wl_surface associated with this xdg_surface.
+ *
+ * The width and height must be greater than zero. Setting an invalid size
+ * will raise an error. When applied, the effective window geometry will be
+ * the set window geometry clamped to the bounding rectangle of the
+ * combined geometry of the surface of the xdg_surface and the associated
+ * subsurfaces.
+ */
+static inline void
+zxdg_surface_v6_set_window_geometry(struct zxdg_surface_v6 *zxdg_surface_v6, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * When a configure event is received, if a client commits the
+ * surface in response to the configure event, then the client
+ * must make an ack_configure request sometime before the commit
+ * request, passing along the serial of the configure event.
+ *
+ * For instance, for toplevel surfaces the compositor might use this
+ * information to move a surface to the top left only when the client has
+ * drawn itself for the maximized or fullscreen state.
+ *
+ * If the client receives multiple configure events before it
+ * can respond to one, it only has to ack the last configure event.
+ *
+ * A client is not required to commit immediately after sending
+ * an ack_configure request - it may even ack_configure several times
+ * before its next surface commit.
+ *
+ * A client may send multiple ack_configure requests before committing, but
+ * only the last request sent before a commit indicates which configure
+ * event the client really is responding to.
+ */
+static inline void
+zxdg_surface_v6_ack_configure(struct zxdg_surface_v6 *zxdg_surface_v6, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_ACK_CONFIGURE, serial);
+}
+
+#ifndef ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM
+#define ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation.
+ */
+enum zxdg_toplevel_v6_resize_edge {
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE = 0,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP = 1,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM = 2,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_LEFT = 4,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_LEFT = 5,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_RIGHT = 8,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_RIGHT = 9,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+#endif /* ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM */
+
+#ifndef ZXDG_TOPLEVEL_V6_STATE_ENUM
+#define ZXDG_TOPLEVEL_V6_STATE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * the surface is now activated
+ *
+ * Client window decorations should be painted as if the window is
+ * active. Do not assume this means that the window actually has
+ * keyboard or pointer focus.
+ */
+enum zxdg_toplevel_v6_state {
+	/**
+	 * the surface is maximized
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_MAXIMIZED = 1,
+	/**
+	 * the surface is fullscreen
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN = 2,
+	/**
+	 * the surface is being resized
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_RESIZING = 3,
+	/**
+	 * the surface is now activated
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_ACTIVATED = 4,
+};
+#endif /* ZXDG_TOPLEVEL_V6_STATE_ENUM */
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * @struct zxdg_toplevel_v6_listener
+ */
+struct zxdg_toplevel_v6_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * This configure event asks the client to resize its toplevel
+	 * surface or to change its state. The configured state should not
+	 * be applied immediately. See xdg_surface.configure for details.
+	 *
+	 * The width and height arguments specify a hint to the window
+	 * about how its surface should be resized in window geometry
+	 * coordinates. See set_window_geometry.
+	 *
+	 * If the width or height arguments are zero, it means the client
+	 * should decide its own window dimension. This may happen when the
+	 * compositor need to configure the state of the surface but
+	 * doesn't have any information about any previous or expected
+	 * dimension.
+	 *
+	 * The states listed in the event specify how the width/height
+	 * arguments should be interpreted, and possibly how it should be
+	 * drawn.
+	 *
+	 * Clients must send an ack_configure in response to this event.
+	 * See xdg_surface.configure and xdg_surface.ack_configure for
+	 * details.
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_toplevel_v6 *zxdg_toplevel_v6,
+			  int32_t width,
+			  int32_t height,
+			  struct wl_array *states);
+	/**
+	 * surface wants to be closed
+	 *
+	 * The close event is sent by the compositor when the user wants
+	 * the surface to be closed. This should be equivalent to the user
+	 * clicking the close button in client-side decorations, if your
+	 * application has any...
+	 *
+	 * This is only a request that the user intends to close your
+	 * window. The client may choose to ignore this request, or show a
+	 * dialog to ask the user to save their data...
+	 */
+	void (*close)(void *data,
+		      struct zxdg_toplevel_v6 *zxdg_toplevel_v6);
+};
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+static inline int
+zxdg_toplevel_v6_add_listener(struct zxdg_toplevel_v6 *zxdg_toplevel_v6,
+			      const struct zxdg_toplevel_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_toplevel_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_TOPLEVEL_V6_DESTROY 0
+#define ZXDG_TOPLEVEL_V6_SET_PARENT 1
+#define ZXDG_TOPLEVEL_V6_SET_TITLE 2
+#define ZXDG_TOPLEVEL_V6_SET_APP_ID 3
+#define ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU 4
+#define ZXDG_TOPLEVEL_V6_MOVE 5
+#define ZXDG_TOPLEVEL_V6_RESIZE 6
+#define ZXDG_TOPLEVEL_V6_SET_MAX_SIZE 7
+#define ZXDG_TOPLEVEL_V6_SET_MIN_SIZE 8
+#define ZXDG_TOPLEVEL_V6_SET_MAXIMIZED 9
+#define ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED 10
+#define ZXDG_TOPLEVEL_V6_SET_FULLSCREEN 11
+#define ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN 12
+#define ZXDG_TOPLEVEL_V6_SET_MINIMIZED 13
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_CLOSE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_PARENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_APP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MAX_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MIN_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MINIMIZED_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_toplevel_v6 */
+static inline void
+zxdg_toplevel_v6_set_user_data(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_toplevel_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_toplevel_v6 */
+static inline void *
+zxdg_toplevel_v6_get_user_data(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+static inline uint32_t
+zxdg_toplevel_v6_get_version(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Unmap and destroy the window. The window will be effectively
+ * hidden from the user's point of view, and all state like
+ * maximization, fullscreen, and so on, will be lost.
+ */
+static inline void
+zxdg_toplevel_v6_destroy(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set the "parent" of this surface. This window should be stacked
+ * above a parent. The parent surface must be mapped as long as this
+ * surface is mapped.
+ *
+ * Parent windows should be set on dialogs, toolboxes, or other
+ * "auxiliary" surfaces, so that the parent is raised when the dialog
+ * is raised.
+ */
+static inline void
+zxdg_toplevel_v6_set_parent(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct zxdg_toplevel_v6 *parent)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_PARENT, parent);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a short title for the surface.
+ *
+ * This string may be used to identify the surface in a task bar,
+ * window list, or other user interface elements provided by the
+ * compositor.
+ *
+ * The string must be encoded in UTF-8.
+ */
+static inline void
+zxdg_toplevel_v6_set_title(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, const char *title)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_TITLE, title);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set an application identifier for the surface.
+ *
+ * The app ID identifies the general class of applications to which
+ * the surface belongs. The compositor can use this to group multiple
+ * surfaces together, or to determine how to launch a new application.
+ *
+ * For D-Bus activatable applications, the app ID is used as the D-Bus
+ * service name.
+ *
+ * The compositor shell will try to group application surfaces together
+ * by their app ID.  As a best practice, it is suggested to select app
+ * ID's that match the basename of the application's .desktop file.
+ * For example, "org.freedesktop.FooViewer" where the .desktop file is
+ * "org.freedesktop.FooViewer.desktop".
+ *
+ * See the desktop-entry specification [0] for more details on
+ * application identifiers and how they relate to well-known D-Bus
+ * names and .desktop files.
+ *
+ * [0] http://standards.freedesktop.org/desktop-entry-spec/
+ */
+static inline void
+zxdg_toplevel_v6_set_app_id(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, const char *app_id)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_APP_ID, app_id);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Clients implementing client-side decorations might want to show
+ * a context menu when right-clicking on the decorations, giving the
+ * user a menu that they can use to maximize or minimize the window.
+ *
+ * This request asks the compositor to pop up such a window menu at
+ * the given position, relative to the local surface coordinates of
+ * the parent surface. There are no guarantees as to what menu items
+ * the window menu contains.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event.
+ */
+static inline void
+zxdg_toplevel_v6_show_window_menu(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU, seat, serial, x, y);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Start an interactive, user-driven move of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive move (touch,
+ * pointer, etc).
+ *
+ * The server may ignore move requests depending on the state of
+ * the surface (e.g. fullscreen or maximized), or if the passed serial
+ * is no longer valid.
+ *
+ * If triggered, the surface will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the move. It is up to the
+ * compositor to visually indicate that the move is taking place, such as
+ * updating a pointer cursor, during the move. There is no guarantee
+ * that the device focus will return when the move is completed.
+ */
+static inline void
+zxdg_toplevel_v6_move(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_MOVE, seat, serial);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Start a user-driven, interactive resize of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive resize (touch,
+ * pointer, etc).
+ *
+ * The server may ignore resize requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ *
+ * If triggered, the client will receive configure events with the
+ * "resize" state enum value and the expected sizes. See the "resize"
+ * enum value for more details about what is required. The client
+ * must also acknowledge configure events using "ack_configure". After
+ * the resize is completed, the client will receive another "configure"
+ * event without the resize state.
+ *
+ * If triggered, the surface also will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
+ * compositor to visually indicate that the resize is taking place,
+ * such as updating a pointer cursor, during the resize. There is no
+ * guarantee that the device focus will return when the resize is
+ * completed.
+ *
+ * The edges parameter specifies how the surface should be resized,
+ * and is one of the values of the resize_edge enum. The compositor
+ * may use this information to update the surface position for
+ * example when dragging the top left corner. The compositor may also
+ * use this information to adapt its behavior, e.g. choose an
+ * appropriate cursor image.
+ */
+static inline void
+zxdg_toplevel_v6_resize(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_RESIZE, seat, serial, edges);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a maximum size for the window.
+ *
+ * The client can specify a maximum size so that the compositor does
+ * not try to configure the window beyond this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the maximum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a larger size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected maximum size in the given dimension.
+ * As a result, a client wishing to reset the maximum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a maximum size to be smaller than the minimum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+zxdg_toplevel_v6_set_max_size(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MAX_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a minimum size for the window.
+ *
+ * The client can specify a minimum size so that the compositor does
+ * not try to configure the window below this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the minimum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a smaller size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected minimum size in the given dimension.
+ * As a result, a client wishing to reset the minimum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a minimum size to be larger than the maximum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+zxdg_toplevel_v6_set_min_size(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MIN_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Maximize the surface.
+ *
+ * After requesting that the surface should be maximized, the compositor
+ * will respond by emitting a configure event with the "maximized" state
+ * and the required window geometry. The client should then update its
+ * content, drawing it in a maximized state, i.e. without shadow or other
+ * decoration outside of the window geometry. The client must also
+ * acknowledge the configure when committing the new content (see
+ * ack_configure).
+ *
+ * It is up to the compositor to decide how and where to maximize the
+ * surface, for example which output and what region of the screen should
+ * be used.
+ *
+ * If the surface was already maximized, the compositor will still emit
+ * a configure event with the "maximized" state.
+ */
+static inline void
+zxdg_toplevel_v6_set_maximized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Unmaximize the surface.
+ *
+ * After requesting that the surface should be unmaximized, the compositor
+ * will respond by emitting a configure event without the "maximized"
+ * state. If available, the compositor will include the window geometry
+ * dimensions the window had prior to being maximized in the configure
+ * request. The client must then update its content, drawing it in a
+ * regular state, i.e. potentially with shadow, etc. The client must also
+ * acknowledge the configure when committing the new content (see
+ * ack_configure).
+ *
+ * It is up to the compositor to position the surface after it was
+ * unmaximized; usually the position the surface had before maximizing, if
+ * applicable.
+ *
+ * If the surface was already not maximized, the compositor will still
+ * emit a configure event without the "maximized" state.
+ */
+static inline void
+zxdg_toplevel_v6_unset_maximized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Make the surface fullscreen.
+ *
+ * You can specify an output that you would prefer to be fullscreen.
+ * If this value is NULL, it's up to the compositor to choose which
+ * display will be used to map this surface.
+ *
+ * If the surface doesn't cover the whole output, the compositor will
+ * position the surface in the center of the output and compensate with
+ * black borders filling the rest of the output.
+ */
+static inline void
+zxdg_toplevel_v6_set_fullscreen(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_FULLSCREEN, output);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+static inline void
+zxdg_toplevel_v6_unset_fullscreen(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Request that the compositor minimize your surface. There is no
+ * way to know if the surface is currently minimized, nor is there
+ * any way to unset minimization on this surface.
+ *
+ * If you are looking to throttle redrawing when minimized, please
+ * instead use the wl_surface.frame event for this, as this will
+ * also work with live previews on windows in Alt-Tab, Expose or
+ * similar compositor features.
+ */
+static inline void
+zxdg_toplevel_v6_set_minimized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MINIMIZED);
+}
+
+#ifndef ZXDG_POPUP_V6_ERROR_ENUM
+#define ZXDG_POPUP_V6_ERROR_ENUM
+enum zxdg_popup_v6_error {
+	/**
+	 * tried to grab after being mapped
+	 */
+	ZXDG_POPUP_V6_ERROR_INVALID_GRAB = 0,
+};
+#endif /* ZXDG_POPUP_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ * @struct zxdg_popup_v6_listener
+ */
+struct zxdg_popup_v6_listener {
+	/**
+	 * configure the popup surface
+	 *
+	 * This event asks the popup surface to configure itself given
+	 * the configuration. The configured state should not be applied
+	 * immediately. See xdg_surface.configure for details.
+	 *
+	 * The x and y arguments represent the position the popup was
+	 * placed at given the xdg_positioner rule, relative to the upper
+	 * left corner of the window geometry of the parent surface.
+	 * @param x x position relative to parent surface window geometry
+	 * @param y y position relative to parent surface window geometry
+	 * @param width window geometry width
+	 * @param height window geometry height
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_popup_v6 *zxdg_popup_v6,
+			  int32_t x,
+			  int32_t y,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * popup interaction is done
+	 *
+	 * The popup_done event is sent out when a popup is dismissed by
+	 * the compositor. The client should destroy the xdg_popup object
+	 * at this point.
+	 */
+	void (*popup_done)(void *data,
+			   struct zxdg_popup_v6 *zxdg_popup_v6);
+};
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+static inline int
+zxdg_popup_v6_add_listener(struct zxdg_popup_v6 *zxdg_popup_v6,
+			   const struct zxdg_popup_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_popup_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_POPUP_V6_DESTROY 0
+#define ZXDG_POPUP_V6_GRAB 1
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_POPUP_DONE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_GRAB_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_popup_v6 */
+static inline void
+zxdg_popup_v6_set_user_data(struct zxdg_popup_v6 *zxdg_popup_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_popup_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_popup_v6 */
+static inline void *
+zxdg_popup_v6_get_user_data(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_popup_v6);
+}
+
+static inline uint32_t
+zxdg_popup_v6_get_version(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_popup_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ *
+ * This destroys the popup. Explicitly destroying the xdg_popup
+ * object will also dismiss the popup, and unmap the surface.
+ *
+ * If this xdg_popup is not the "topmost" popup, a protocol error
+ * will be sent.
+ */
+static inline void
+zxdg_popup_v6_destroy(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_popup_v6,
+			 ZXDG_POPUP_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_popup_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ *
+ * This request makes the created popup take an explicit grab. An explicit
+ * grab will be dismissed when the user dismisses the popup, or when the
+ * client destroys the xdg_popup. This can be done by the user clicking
+ * outside the surface, using the keyboard, or even locking the screen
+ * through closing the lid or a timeout.
+ *
+ * If the compositor denies the grab, the popup will be immediately
+ * dismissed.
+ *
+ * This request must be used in response to some sort of user action like a
+ * button press, key press, or touch down event. The serial number of the
+ * event should be passed as 'serial'.
+ *
+ * The parent of a grabbing popup must either be an xdg_toplevel surface or
+ * another xdg_popup with an explicit grab. If the parent is another
+ * xdg_popup it means that the popups are nested, with this popup now being
+ * the topmost popup.
+ *
+ * Nested popups must be destroyed in the reverse order they were created
+ * in, e.g. the only popup you are allowed to destroy at all times is the
+ * topmost one.
+ *
+ * When compositors choose to dismiss a popup, they may dismiss every
+ * nested grabbing popup as well. When a compositor dismisses popups, it
+ * will follow the same dismissing order as required from the client.
+ *
+ * The parent of a grabbing popup must either be another xdg_popup with an
+ * active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
+ * explicit grabs already taken.
+ *
+ * If the topmost grabbing popup is destroyed, the grab will be returned to
+ * the parent of the popup, if that parent previously had an explicit grab.
+ *
+ * If the parent is a grabbing popup which has already been dismissed, this
+ * popup will be immediately dismissed. If the parent is a popup that did
+ * not take an explicit grab, an error will be raised.
+ *
+ * During a popup grab, the client owning the grab will receive pointer
+ * and touch events for all their surfaces as normal (similar to an
+ * "owner-events" grab in X11 parlance), while the top most grabbing popup
+ * will always have keyboard focus.
+ */
+static inline void
+zxdg_popup_v6_grab(struct zxdg_popup_v6 *zxdg_popup_v6, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_popup_v6,
+			 ZXDG_POPUP_V6_GRAB, seat, serial);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/gdk/wayland/xdg-shell-unstable-v6-protocol.c b/gdk/wayland/xdg-shell-unstable-v6-protocol.c
new file mode 100755
index 0000000..ef4a7d2
--- /dev/null
+++ b/gdk/wayland/xdg-shell-unstable-v6-protocol.c
@@ -0,0 +1,162 @@
+/* Generated by wayland-scanner 1.13.0 */
+
+/*
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_output_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zxdg_popup_v6_interface;
+extern const struct wl_interface zxdg_positioner_v6_interface;
+extern const struct wl_interface zxdg_surface_v6_interface;
+extern const struct wl_interface zxdg_toplevel_v6_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&zxdg_positioner_v6_interface,
+	&zxdg_surface_v6_interface,
+	&wl_surface_interface,
+	&zxdg_toplevel_v6_interface,
+	&zxdg_popup_v6_interface,
+	&zxdg_surface_v6_interface,
+	&zxdg_positioner_v6_interface,
+	&zxdg_toplevel_v6_interface,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	&wl_output_interface,
+	&wl_seat_interface,
+	NULL,
+};
+
+static const struct wl_message zxdg_shell_v6_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "create_positioner", "n", types + 4 },
+	{ "get_xdg_surface", "no", types + 5 },
+	{ "pong", "u", types + 0 },
+};
+
+static const struct wl_message zxdg_shell_v6_events[] = {
+	{ "ping", "u", types + 0 },
+};
+
+const struct wl_interface zxdg_shell_v6_interface = {
+	"zxdg_shell_v6", 1,
+	4, zxdg_shell_v6_requests,
+	1, zxdg_shell_v6_events,
+};
+
+static const struct wl_message zxdg_positioner_v6_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "set_size", "ii", types + 0 },
+	{ "set_anchor_rect", "iiii", types + 0 },
+	{ "set_anchor", "u", types + 0 },
+	{ "set_gravity", "u", types + 0 },
+	{ "set_constraint_adjustment", "u", types + 0 },
+	{ "set_offset", "ii", types + 0 },
+};
+
+const struct wl_interface zxdg_positioner_v6_interface = {
+	"zxdg_positioner_v6", 1,
+	7, zxdg_positioner_v6_requests,
+	0, NULL,
+};
+
+static const struct wl_message zxdg_surface_v6_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "get_toplevel", "n", types + 7 },
+	{ "get_popup", "noo", types + 8 },
+	{ "set_window_geometry", "iiii", types + 0 },
+	{ "ack_configure", "u", types + 0 },
+};
+
+static const struct wl_message zxdg_surface_v6_events[] = {
+	{ "configure", "u", types + 0 },
+};
+
+const struct wl_interface zxdg_surface_v6_interface = {
+	"zxdg_surface_v6", 1,
+	5, zxdg_surface_v6_requests,
+	1, zxdg_surface_v6_events,
+};
+
+static const struct wl_message zxdg_toplevel_v6_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "set_parent", "?o", types + 11 },
+	{ "set_title", "s", types + 0 },
+	{ "set_app_id", "s", types + 0 },
+	{ "show_window_menu", "ouii", types + 12 },
+	{ "move", "ou", types + 16 },
+	{ "resize", "ouu", types + 18 },
+	{ "set_max_size", "ii", types + 0 },
+	{ "set_min_size", "ii", types + 0 },
+	{ "set_maximized", "", types + 0 },
+	{ "unset_maximized", "", types + 0 },
+	{ "set_fullscreen", "?o", types + 21 },
+	{ "unset_fullscreen", "", types + 0 },
+	{ "set_minimized", "", types + 0 },
+};
+
+static const struct wl_message zxdg_toplevel_v6_events[] = {
+	{ "configure", "iia", types + 0 },
+	{ "close", "", types + 0 },
+};
+
+const struct wl_interface zxdg_toplevel_v6_interface = {
+	"zxdg_toplevel_v6", 1,
+	14, zxdg_toplevel_v6_requests,
+	2, zxdg_toplevel_v6_events,
+};
+
+static const struct wl_message zxdg_popup_v6_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "grab", "ou", types + 22 },
+};
+
+static const struct wl_message zxdg_popup_v6_events[] = {
+	{ "configure", "iiii", types + 0 },
+	{ "popup_done", "", types + 0 },
+};
+
+const struct wl_interface zxdg_popup_v6_interface = {
+	"zxdg_popup_v6", 1,
+	2, zxdg_popup_v6_requests,
+	2, zxdg_popup_v6_events,
+};
+
-- 
1.9.1

